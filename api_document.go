/*
CouchDB API

*Note* This is not a definitive implementation of the CouchDB API, it's missing a lot of the endpoints for server/database managment and everything for attachments all COPY operations and probably a few other parts.  It also targets golang, as such the '#/definitions/Document' is intentionally left empty to generate a go `interface`, which you can then cast to a `map[string]interface{}`. 

API version: 4.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package couchdb_go

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type DocumentApi interface {

	/*
	DocDelete Marks the specified document as deleted by adding a field _deleted with the value true.

	Documents with this field will not be returned within requests anymore, but stay in the database. 
You must supply the current (latest) revision, either by using the rev parameter or by using the
If-Match header to specify the revision.

*Notes*
CouchDB doesn’t completely delete the specified document. Instead, it leaves a tombstone with very 
basic information about the document. The tombstone is required so that the delete action can be 
replicated across databases.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@param docid DDocument ID
	@return ApiDocDeleteRequest
	*/
	DocDelete(ctx context.Context, db string, docid string) ApiDocDeleteRequest

	// DocDeleteExecute executes the request
	//  @return DocumentOK
	DocDeleteExecute(r ApiDocDeleteRequest) (*DocumentOK, *http.Response, error)

	/*
	DocGet Returns document by the specified docid from the specified db. Unless you request a specific revision, the latest revision of the document will always be returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@param docid DDocument ID
	@return ApiDocGetRequest
	*/
	DocGet(ctx context.Context, db string, docid string) ApiDocGetRequest

	// DocGetExecute executes the request
	//  @return map[string]interface{}
	DocGetExecute(r ApiDocGetRequest) (map[string]interface{}, *http.Response, error)

	/*
	DocInfo Returns the HTTP Headers containing a minimal amount of information about the specified document.

	The method supports the same query arguments as the GET /{db}/{docid} method, 
but only the header information (including document size, and the revision as an ETag), is returned.

The ETag header shows the current revision for the requested document, and the Content-Length 
specifies the length of the data, if the document were requested in full.

Adding any of the query arguments (see GET /{db}/{docid}), then the resulting HTTP Headers 
will correspond to what would be returned.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@param docid DDocument ID
	@return ApiDocInfoRequest
	*/
	DocInfo(ctx context.Context, db string, docid string) ApiDocInfoRequest

	// DocInfoExecute executes the request
	DocInfoExecute(r ApiDocInfoRequest) (*http.Response, error)

	/*
	DocPut The PUT method creates a new named document, or creates a new revision of the existing document. Unlike the POST /{db}, you must specify the document ID in the request URL.

	When updating an existing document, the current document revision must be included in the document 
(i.e. the request body), as the rev query parameter, or in the If-Match request header.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@param docid DDocument ID
	@return ApiDocPutRequest
	*/
	DocPut(ctx context.Context, db string, docid string) ApiDocPutRequest

	// DocPutExecute executes the request
	//  @return DocumentOK
	DocPutExecute(r ApiDocPutRequest) (*DocumentOK, *http.Response, error)

	/*
	Post Creates a new document in the specified database, using the supplied JSON document structure.

	If the JSON structure includes the _id field, then the document will be created with the 
specified document ID.

If the _id field is not specified, a new unique ID will be generated, following whatever 
UUID algorithm is configured for that server.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@return ApiPostRequest
	*/
	Post(ctx context.Context, db string) ApiPostRequest

	// PostExecute executes the request
	//  @return DocumentOK
	PostExecute(r ApiPostRequest) (*DocumentOK, *http.Response, error)
}

// DocumentApiService DocumentApi service
type DocumentApiService service

type ApiDocDeleteRequest struct {
	ctx context.Context
	ApiService DocumentApi
	db string
	docid string
	ifMatch *string
	rev *string
	batch *string
}

// Document’s revision. Alternative to rev query parameter
func (r ApiDocDeleteRequest) IfMatch(ifMatch string) ApiDocDeleteRequest {
	r.ifMatch = &ifMatch
	return r
}

// Actual document’s revision
func (r ApiDocDeleteRequest) Rev(rev string) ApiDocDeleteRequest {
	r.rev = &rev
	return r
}

// Stores document in batch mode Possible values: ok. Optional 
func (r ApiDocDeleteRequest) Batch(batch string) ApiDocDeleteRequest {
	r.batch = &batch
	return r
}

func (r ApiDocDeleteRequest) Execute() (*DocumentOK, *http.Response, error) {
	return r.ApiService.DocDeleteExecute(r)
}

/*
DocDelete Marks the specified document as deleted by adding a field _deleted with the value true.

Documents with this field will not be returned within requests anymore, but stay in the database. 
You must supply the current (latest) revision, either by using the rev parameter or by using the
If-Match header to specify the revision.

*Notes*
CouchDB doesn’t completely delete the specified document. Instead, it leaves a tombstone with very 
basic information about the document. The tombstone is required so that the delete action can be 
replicated across databases.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param docid DDocument ID
 @return ApiDocDeleteRequest
*/
func (a *DocumentApiService) DocDelete(ctx context.Context, db string, docid string) ApiDocDeleteRequest {
	return ApiDocDeleteRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		docid: docid,
	}
}

// Execute executes the request
//  @return DocumentOK
func (a *DocumentApiService) DocDeleteExecute(r ApiDocDeleteRequest) (*DocumentOK, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DocumentOK
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.DocDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/{docid}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"docid"+"}", url.PathEscape(parameterValueToString(r.docid, "docid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.rev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rev", r.rev, "")
	}
	if r.batch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batch", r.batch, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocGetRequest struct {
	ctx context.Context
	ApiService DocumentApi
	db string
	docid string
	ifNoneMatch *string
	attachments *bool
	attEncodingInfo *bool
	attsSince *[]string
	conflicts *bool
	deletedConflicts *bool
	latest *bool
	localSeq *bool
	meta *bool
	openRevs *[]string
	rev *string
	revs *bool
	revsInfo *bool
}

// Double quoted document’s revision token
func (r ApiDocGetRequest) IfNoneMatch(ifNoneMatch string) ApiDocGetRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// Includes attachments bodies in response. Default is false
func (r ApiDocGetRequest) Attachments(attachments bool) ApiDocGetRequest {
	r.attachments = &attachments
	return r
}

// Includes encoding information in attachment stubs if the particular attachment is compressed. Default is false.
func (r ApiDocGetRequest) AttEncodingInfo(attEncodingInfo bool) ApiDocGetRequest {
	r.attEncodingInfo = &attEncodingInfo
	return r
}

// Includes attachments only since specified revisions. Doesn’t includes attachments for specified revisions. Optional
func (r ApiDocGetRequest) AttsSince(attsSince []string) ApiDocGetRequest {
	r.attsSince = &attsSince
	return r
}

// Includes information about conflicts in document. Default is false
func (r ApiDocGetRequest) Conflicts(conflicts bool) ApiDocGetRequest {
	r.conflicts = &conflicts
	return r
}

// Includes information about deleted conflicted revisions. Default is false
func (r ApiDocGetRequest) DeletedConflicts(deletedConflicts bool) ApiDocGetRequest {
	r.deletedConflicts = &deletedConflicts
	return r
}

// Forces retrieving latest “leaf” revision, no matter what rev was requested. Default is false
func (r ApiDocGetRequest) Latest(latest bool) ApiDocGetRequest {
	r.latest = &latest
	return r
}

// Includes last update sequence for the document. Default is false
func (r ApiDocGetRequest) LocalSeq(localSeq bool) ApiDocGetRequest {
	r.localSeq = &localSeq
	return r
}

// Acts same as specifying all conflicts, deleted_conflicts and revs_info query parameters. Default is false
func (r ApiDocGetRequest) Meta(meta bool) ApiDocGetRequest {
	r.meta = &meta
	return r
}

// Retrieves documents of specified leaf revisions. Additionally, it accepts value as all to return all leaf revisions. Optional
func (r ApiDocGetRequest) OpenRevs(openRevs []string) ApiDocGetRequest {
	r.openRevs = &openRevs
	return r
}

// Retrieves document of specified revision. Optional
func (r ApiDocGetRequest) Rev(rev string) ApiDocGetRequest {
	r.rev = &rev
	return r
}

// Includes list of all known document revisions. Default is false
func (r ApiDocGetRequest) Revs(revs bool) ApiDocGetRequest {
	r.revs = &revs
	return r
}

// Includes detailed information for all known document revisions. Default is false
func (r ApiDocGetRequest) RevsInfo(revsInfo bool) ApiDocGetRequest {
	r.revsInfo = &revsInfo
	return r
}

func (r ApiDocGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DocGetExecute(r)
}

/*
DocGet Returns document by the specified docid from the specified db. Unless you request a specific revision, the latest revision of the document will always be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param docid DDocument ID
 @return ApiDocGetRequest
*/
func (a *DocumentApiService) DocGet(ctx context.Context, db string, docid string) ApiDocGetRequest {
	return ApiDocGetRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		docid: docid,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DocumentApiService) DocGetExecute(r ApiDocGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.DocGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/{docid}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"docid"+"}", url.PathEscape(parameterValueToString(r.docid, "docid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifNoneMatch == nil {
		return localVarReturnValue, nil, reportError("ifNoneMatch is required and must be specified")
	}

	if r.attachments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachments", r.attachments, "")
	}
	if r.attEncodingInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "att_encoding_info", r.attEncodingInfo, "")
	}
	if r.attsSince != nil {
		t := *r.attsSince
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "atts_since", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "atts_since", t, "multi")
		}
	}
	if r.conflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicts", r.conflicts, "")
	}
	if r.deletedConflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_conflicts", r.deletedConflicts, "")
	}
	if r.latest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latest", r.latest, "")
	}
	if r.localSeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local_seq", r.localSeq, "")
	}
	if r.meta != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "meta", r.meta, "")
	}
	if r.openRevs != nil {
		t := *r.openRevs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "open_revs", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "open_revs", t, "multi")
		}
	}
	if r.rev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rev", r.rev, "")
	}
	if r.revs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revs", r.revs, "")
	}
	if r.revsInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revs_info", r.revsInfo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "multipart/related", "multipart/mixed", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocInfoRequest struct {
	ctx context.Context
	ApiService DocumentApi
	db string
	docid string
}

func (r ApiDocInfoRequest) Execute() (*http.Response, error) {
	return r.ApiService.DocInfoExecute(r)
}

/*
DocInfo Returns the HTTP Headers containing a minimal amount of information about the specified document.

The method supports the same query arguments as the GET /{db}/{docid} method, 
but only the header information (including document size, and the revision as an ETag), is returned.

The ETag header shows the current revision for the requested document, and the Content-Length 
specifies the length of the data, if the document were requested in full.

Adding any of the query arguments (see GET /{db}/{docid}), then the resulting HTTP Headers 
will correspond to what would be returned.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param docid DDocument ID
 @return ApiDocInfoRequest
*/
func (a *DocumentApiService) DocInfo(ctx context.Context, db string, docid string) ApiDocInfoRequest {
	return ApiDocInfoRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		docid: docid,
	}
}

// Execute executes the request
func (a *DocumentApiService) DocInfoExecute(r ApiDocInfoRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.DocInfo")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/{docid}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"docid"+"}", url.PathEscape(parameterValueToString(r.docid, "docid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDocPutRequest struct {
	ctx context.Context
	ApiService DocumentApi
	db string
	docid string
	body *map[string]interface{}
	ifMatch *string
	rev *string
	batch *string
	newEdits *bool
}

func (r ApiDocPutRequest) Body(body map[string]interface{}) ApiDocPutRequest {
	r.body = &body
	return r
}

// Document’s revision. Alternative to rev query parameter or document key. Optional
func (r ApiDocPutRequest) IfMatch(ifMatch string) ApiDocPutRequest {
	r.ifMatch = &ifMatch
	return r
}

// Document’s revision if updating an existing document. Alternative to If-Match header or document key. Optional
func (r ApiDocPutRequest) Rev(rev string) ApiDocPutRequest {
	r.rev = &rev
	return r
}

// Stores document in batch mode. Possible values: ok. Optional 
func (r ApiDocPutRequest) Batch(batch string) ApiDocPutRequest {
	r.batch = &batch
	return r
}

// Prevents insertion of a conflicting document. Possible values: true (default) and false. If false,  a well-formed _rev must be included in the document. new_edits&#x3D;false is used by the replicator  to insert documents into the target database even if that leads to the creation of conflicts. Optional 
func (r ApiDocPutRequest) NewEdits(newEdits bool) ApiDocPutRequest {
	r.newEdits = &newEdits
	return r
}

func (r ApiDocPutRequest) Execute() (*DocumentOK, *http.Response, error) {
	return r.ApiService.DocPutExecute(r)
}

/*
DocPut The PUT method creates a new named document, or creates a new revision of the existing document. Unlike the POST /{db}, you must specify the document ID in the request URL.

When updating an existing document, the current document revision must be included in the document 
(i.e. the request body), as the rev query parameter, or in the If-Match request header.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param docid DDocument ID
 @return ApiDocPutRequest
*/
func (a *DocumentApiService) DocPut(ctx context.Context, db string, docid string) ApiDocPutRequest {
	return ApiDocPutRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		docid: docid,
	}
}

// Execute executes the request
//  @return DocumentOK
func (a *DocumentApiService) DocPutExecute(r ApiDocPutRequest) (*DocumentOK, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DocumentOK
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.DocPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/{docid}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"docid"+"}", url.PathEscape(parameterValueToString(r.docid, "docid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.rev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rev", r.rev, "")
	}
	if r.batch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batch", r.batch, "")
	}
	if r.newEdits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "new_edits", r.newEdits, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRequest struct {
	ctx context.Context
	ApiService DocumentApi
	db string
	body *map[string]interface{}
	batch *string
}

func (r ApiPostRequest) Body(body map[string]interface{}) ApiPostRequest {
	r.body = &body
	return r
}

// Stores document in batch mode Possible values: ok. Optional 
func (r ApiPostRequest) Batch(batch string) ApiPostRequest {
	r.batch = &batch
	return r
}

func (r ApiPostRequest) Execute() (*DocumentOK, *http.Response, error) {
	return r.ApiService.PostExecute(r)
}

/*
Post Creates a new document in the specified database, using the supplied JSON document structure.

If the JSON structure includes the _id field, then the document will be created with the 
specified document ID.

If the _id field is not specified, a new unique ID will be generated, following whatever 
UUID algorithm is configured for that server.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @return ApiPostRequest
*/
func (a *DocumentApiService) Post(ctx context.Context, db string) ApiPostRequest {
	return ApiPostRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
	}
}

// Execute executes the request
//  @return DocumentOK
func (a *DocumentApiService) PostExecute(r ApiPostRequest) (*DocumentOK, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DocumentOK
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentApiService.Post")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.batch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batch", r.batch, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
