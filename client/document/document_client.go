// Code generated by go-swagger; DO NOT EDIT.

package document

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new document API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for document API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	Doc(params *DocParams, authInfo runtime.ClientAuthInfoWriter) (*DocOK, error)

	DocDelete(params *DocDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*DocDeleteOK, *DocDeleteAccepted, error)

	DocGet(params *DocGetParams, authInfo runtime.ClientAuthInfoWriter) (*DocGetOK, error)

	DocPut(params *DocPutParams, authInfo runtime.ClientAuthInfoWriter) (*DocPutCreated, *DocPutAccepted, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  Doc returns the HTTP headers containing a minimal amount of information about the specified document

  The method supports the same query arguments as the GET /{db}/{docid} method,
but only the header information (including document size, and the revision as an ETag), is returned.

The ETag header shows the current revision for the requested document, and the Content-Length
specifies the length of the data, if the document were requested in full.

Adding any of the query arguments (see GET /{db}/{docid}), then the resulting HTTP Headers
will correspond to what would be returned.

*/
func (a *Client) Doc(params *DocParams, authInfo runtime.ClientAuthInfoWriter) (*DocOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDocParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "doc",
		Method:             "HEAD",
		PathPattern:        "/{db}/{docid}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DocReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DocOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for doc: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DocDelete marks the specified document as deleted by adding a field deleted with the value true

  Documents with this field will not be returned within requests anymore, but stay in the database.
You must supply the current (latest) revision, either by using the rev parameter or by using the
If-Match header to specify the revision.

*Notes*
CouchDB doesnâ€™t completely delete the specified document. Instead, it leaves a tombstone with very
basic information about the document. The tombstone is required so that the delete action can be
replicated across databases.

*/
func (a *Client) DocDelete(params *DocDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*DocDeleteOK, *DocDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDocDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "docDelete",
		Method:             "DELETE",
		PathPattern:        "/{db}/{docid}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DocDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DocDeleteOK:
		return value, nil, nil
	case *DocDeleteAccepted:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for document: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DocGet returns document by the specified docid from the specified db unless you request a specific revision the latest revision of the document will always be returned
*/
func (a *Client) DocGet(params *DocGetParams, authInfo runtime.ClientAuthInfoWriter) (*DocGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDocGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "docGet",
		Method:             "GET",
		PathPattern:        "/{db}/{docid}",
		ProducesMediaTypes: []string{"application/json", "multipart/mixed", "multipart/related", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "multipart/mixed", "multipart/related", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DocGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DocGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for docGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DocPut thes p u t method creates a new named document or creates a new revision of the existing document unlike the p o s t db you must specify the document ID in the request URL

  When updating an existing document, the current document revision must be included in the document
(i.e. the request body), as the rev query parameter, or in the If-Match request header.

*/
func (a *Client) DocPut(params *DocPutParams, authInfo runtime.ClientAuthInfoWriter) (*DocPutCreated, *DocPutAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDocPutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "docPut",
		Method:             "PUT",
		PathPattern:        "/{db}/{docid}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DocPutReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DocPutCreated:
		return value, nil, nil
	case *DocPutAccepted:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for document: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
