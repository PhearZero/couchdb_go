// Code generated by go-swagger; DO NOT EDIT.

package database

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new database API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for database API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	DbDelete(params *DbDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*DbDeleteOK, *DbDeleteAccepted, error)

	DbGet(params *DbGetParams, authInfo runtime.ClientAuthInfoWriter) (*DbGetOK, error)

	DbHeader(params *DbHeaderParams, authInfo runtime.ClientAuthInfoWriter) (*DbHeaderOK, error)

	DbPost(params *DbPostParams, authInfo runtime.ClientAuthInfoWriter) (*DbPostCreated, *DbPostAccepted, error)

	DbPut(params *DbPutParams, authInfo runtime.ClientAuthInfoWriter) (*DbPutCreated, *DbPutAccepted, error)

	DocGetAll(params *DocGetAllParams, authInfo runtime.ClientAuthInfoWriter) (*DocGetAllOK, error)

	DocPostAll(params *DocPostAllParams, authInfo runtime.ClientAuthInfoWriter) (*DocPostAllOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  DbDelete deletes the specified database and all the documents and attachments contained within it

  *Note*
To avoid deleting a database, CouchDB will respond with the HTTP status code 400 when the request
URL includes a ?rev= parameter. This suggests that one wants to delete a document but forgot to add
the document id to the URL.

*/
func (a *Client) DbDelete(params *DbDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*DbDeleteOK, *DbDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDbDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "dbDelete",
		Method:             "DELETE",
		PathPattern:        "/{db}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DbDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DbDeleteOK:
		return value, nil, nil
	case *DbDeleteAccepted:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for database: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DbGet gets information about the specified database

  By passing in the appropriate options, you can search for
available inventory in the system

*/
func (a *Client) DbGet(params *DbGetParams, authInfo runtime.ClientAuthInfoWriter) (*DbGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDbGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "dbGet",
		Method:             "GET",
		PathPattern:        "/{db}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DbGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DbGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for dbGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DbHeader returns the HTTP headers containing a minimal amount of information about the specified database

  Since the response body is empty, using the HEAD method is a lightweight way to check if the database exists already or not.

*/
func (a *Client) DbHeader(params *DbHeaderParams, authInfo runtime.ClientAuthInfoWriter) (*DbHeaderOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDbHeaderParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "dbHeader",
		Method:             "HEAD",
		PathPattern:        "/{db}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DbHeaderReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DbHeaderOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for dbHeader: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DbPost creates a new document in the specified database using the supplied JSON document structure

  If the JSON structure includes the _id field, then the document will be created with the
specified document ID.

If the _id field is not specified, a new unique ID will be generated, following whatever
UUID algorithm is configured for that server.

*/
func (a *Client) DbPost(params *DbPostParams, authInfo runtime.ClientAuthInfoWriter) (*DbPostCreated, *DbPostAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDbPostParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "dbPost",
		Method:             "POST",
		PathPattern:        "/{db}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DbPostReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DbPostCreated:
		return value, nil, nil
	case *DbPostAccepted:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for database: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DbPut creates a new database

  The database name {db} must be composed by following next rules:
Name must begin with a lowercase letter (a-z)
* Lowercase characters (a-z)
* Digits (0-9)
* Any of the characters _, $, (, ), +, -, and /.

If youâ€™re familiar with Regular Expressions, the rules above could be written as

*/
func (a *Client) DbPut(params *DbPutParams, authInfo runtime.ClientAuthInfoWriter) (*DbPutCreated, *DbPutAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDbPutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "dbPut",
		Method:             "PUT",
		PathPattern:        "/{db}",
		ProducesMediaTypes: []string{"application/json", "text/plain"},
		ConsumesMediaTypes: []string{"application/json", "text/plain"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DbPutReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DbPutCreated:
		return value, nil, nil
	case *DbPutAccepted:
		return nil, value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for database: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DocGetAll executes the built in all docs view

  returning all of the documents in the database. With the exception of the URL parameters
(described below), this endpoint works identically to any other view. Refer to the view endpoint
documentation for a complete description of the available query parameters and the format of
the returned data.

*/
func (a *Client) DocGetAll(params *DocGetAllParams, authInfo runtime.ClientAuthInfoWriter) (*DocGetAllOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDocGetAllParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "docGetAll",
		Method:             "GET",
		PathPattern:        "/{db}/_all_docs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DocGetAllReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DocGetAllOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for docGetAll: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DocPostAll executes the built in all docs view

  POST _all_docs functionality supports identical parameters and behavior as specified in the
GET /{db}/_all_docs API but allows for the query string parameters to be supplied as keys in a
JSON object in the body of the POST request.

*/
func (a *Client) DocPostAll(params *DocPostAllParams, authInfo runtime.ClientAuthInfoWriter) (*DocPostAllOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDocPostAllParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "docPostAll",
		Method:             "POST",
		PathPattern:        "/{db}/_all_docs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DocPostAllReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DocPostAllOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for docPostAll: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
