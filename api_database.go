/*
CouchDB API

*Note* This is not a definitive implementation of the CouchDB API, it's missing a lot of the endpoints for server/database managment and everything for attachments all COPY operations and probably a few other parts.  It also targets golang, as such the '#/definitions/Document' is intentionally left empty to generate a go `interface`, which you can then cast to a `map[string]interface{}`. 

API version: 4.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package couchdb_go

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type DatabaseApi interface {

	/*
	BulkDocs The bulk document API allows you to create and update multiple documents at the same time within a single request.

	The basic operation is similar to creating or updating a single document, except that you batch the document structure and information.

When creating new documents the document ID (_id) is optional.

For updating existing documents, you must provide the document ID, revision information (_rev), and new document values.

In case of batch deleting documents all fields as document ID, revision information and deletion status (_deleted) are required.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@return ApiBulkDocsRequest
	*/
	BulkDocs(ctx context.Context, db string) ApiBulkDocsRequest

	// BulkDocsExecute executes the request
	//  @return []BulkResponse
	BulkDocsExecute(r ApiBulkDocsRequest) ([]BulkResponse, *http.Response, error)

	/*
	BulkGet This method can be called to query several documents in bulk.

	It is well suited for fetching a specific revision of documents, as replicators do for example, or for getting revision history.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@return ApiBulkGetRequest
	*/
	BulkGet(ctx context.Context, db string) ApiBulkGetRequest

	// BulkGetExecute executes the request
	//  @return Results
	BulkGetExecute(r ApiBulkGetRequest) (*Results, *http.Response, error)

	/*
	DbSecurityGet Returns the current security object from the specified database.

	The security object consists of two compulsory elements, admins and members, which are used to specify the list of users and/or roles that have admin and members rights to the database respectively:

  - members: they can read all types of documents from the DB, and they can write (and edit) documents to the DB except for design documents.
  - admins: they have all the privileges of members plus the privileges: write (and edit) design documents, add/remove database admins and members and set the database revisions limit. They can not create a database nor delete a database.

Both members and admins objects contain two array-typed fields:

  - names: List of CouchDB user names
  - roles: List of users roles

Any additional fields in the security object are optional. The entire security object is made available to validation and other internal functions so that the database can control and limit functionality.

If both the names and roles fields of either the admins or members properties are empty arrays, or are not existent, it means the database has no admins or members.

Having no admins, only server admins (with the reserved _admin role) are able to update design document and make other admin level changes.

Having no members, any user can write regular documents (any non-design document) and read documents from the database.

If there are any member names or roles defined for a database, then only authenticated users having a matching name or role are allowed to read documents from the database (or do a GET /{db} call).

*Note*
If the security object for a database has never been set, then the value returned will be empty.

Also note, that security objects are not regular versioned documents (that is, they are not under MVCC rules). This is a design choice to speed up authorization checks (avoids traversing a database’s documents B-Tree).


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@return ApiDbSecurityGetRequest
	*/
	DbSecurityGet(ctx context.Context, db string) ApiDbSecurityGetRequest

	// DbSecurityGetExecute executes the request
	//  @return InlineResponse2005
	DbSecurityGetExecute(r ApiDbSecurityGetRequest) (*InlineResponse2005, *http.Response, error)

	/*
	Delete Deletes the specified database, and all the documents and attachments contained within it.

	*Note*
To avoid deleting a database, CouchDB will respond with the HTTP status code 400 when the request 
URL includes a ?rev= parameter. This suggests that one wants to delete a document but forgot to add 
the document id to the URL.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@return ApiDeleteRequest
	*/
	Delete(ctx context.Context, db string) ApiDeleteRequest

	// DeleteExecute executes the request
	//  @return OK
	DeleteExecute(r ApiDeleteRequest) (*OK, *http.Response, error)

	/*
	DesignDocAllGet Returns a JSON structure of all of the design documents in a given database.

	The information is returned as a JSON structure containing meta information about the return structure, including a list of all design documents and basic contents, consisting the ID, revision and key. The key is the design document’s _id.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@return ApiDesignDocAllGetRequest
	*/
	DesignDocAllGet(ctx context.Context, db string) ApiDesignDocAllGetRequest

	// DesignDocAllGetExecute executes the request
	//  @return Pagination
	DesignDocAllGetExecute(r ApiDesignDocAllGetRequest) (*Pagination, *http.Response, error)

	/*
	DesignDocAllPost POST _design_docs functionality supports identical parameters and behavior as specified in the GET /{db}/_design_docs

	API but allows for the query string parameters to be supplied as keys in a JSON object in the body of the POST request.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@return ApiDesignDocAllPostRequest
	*/
	DesignDocAllPost(ctx context.Context, db string) ApiDesignDocAllPostRequest

	// DesignDocAllPostExecute executes the request
	//  @return Pagination
	DesignDocAllPostExecute(r ApiDesignDocAllPostRequest) (*Pagination, *http.Response, error)

	/*
	DocGetAll Executes the built-in _all_docs view

	returning all of the documents in the database. With the exception of the URL parameters 
(described below), this endpoint works identically to any other view. Refer to the view endpoint 
documentation for a complete description of the available query parameters and the format of 
the returned data.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@return ApiDocGetAllRequest
	*/
	DocGetAll(ctx context.Context, db string) ApiDocGetAllRequest

	// DocGetAllExecute executes the request
	//  @return Pagination
	DocGetAllExecute(r ApiDocGetAllRequest) (*Pagination, *http.Response, error)

	/*
	DocPostAll Executes the built-in _all_docs view

	POST _all_docs functionality supports identical parameters and behavior as specified in the 
GET /{db}/_all_docs API but allows for the query string parameters to be supplied as keys in a 
JSON object in the body of the POST request.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@return ApiDocPostAllRequest
	*/
	DocPostAll(ctx context.Context, db string) ApiDocPostAllRequest

	// DocPostAllExecute executes the request
	//  @return Pagination
	DocPostAllExecute(r ApiDocPostAllRequest) (*Pagination, *http.Response, error)

	/*
	Exists Returns the HTTP Headers containing a minimal amount of information about the specified database.

	Since the response body is empty, using the HEAD method is a lightweight way to check if the database exists already or not.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@return ApiExistsRequest
	*/
	Exists(ctx context.Context, db string) ApiExistsRequest

	// ExistsExecute executes the request
	ExistsExecute(r ApiExistsRequest) (*http.Response, error)

	/*
	Get Gets information about the specified database.

	By passing in the appropriate options, you can search for
available inventory in the system


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@return ApiGetRequest
	*/
	Get(ctx context.Context, db string) ApiGetRequest

	// GetExecute executes the request
	//  @return Database
	GetExecute(r ApiGetRequest) (*Database, *http.Response, error)

	/*
	Put Creates a new database.

	The database name {db} must be composed by following next rules:
Name must begin with a lowercase letter (a-z)
* Lowercase characters (a-z)
* Digits (0-9)
* Any of the characters _, $, (, ), +, -, and /.

If you’re familiar with Regular Expressions, the rules above could be written as 


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@return ApiPutRequest
	*/
	Put(ctx context.Context, db string) ApiPutRequest

	// PutExecute executes the request
	//  @return OK
	PutExecute(r ApiPutRequest) (*OK, *http.Response, error)

	/*
	SbSecurityPut Sets the security object for the given database.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@return ApiSbSecurityPutRequest
	*/
	SbSecurityPut(ctx context.Context, db string) ApiSbSecurityPutRequest

	// SbSecurityPutExecute executes the request
	//  @return OK
	SbSecurityPutExecute(r ApiSbSecurityPutRequest) (*OK, *http.Response, error)
}

// DatabaseApiService DatabaseApi service
type DatabaseApiService service

type ApiBulkDocsRequest struct {
	ctx context.Context
	ApiService DatabaseApi
	db string
	body *Body3
}

func (r ApiBulkDocsRequest) Body(body Body3) ApiBulkDocsRequest {
	r.body = &body
	return r
}

func (r ApiBulkDocsRequest) Execute() ([]BulkResponse, *http.Response, error) {
	return r.ApiService.BulkDocsExecute(r)
}

/*
BulkDocs The bulk document API allows you to create and update multiple documents at the same time within a single request.

The basic operation is similar to creating or updating a single document, except that you batch the document structure and information.

When creating new documents the document ID (_id) is optional.

For updating existing documents, you must provide the document ID, revision information (_rev), and new document values.

In case of batch deleting documents all fields as document ID, revision information and deletion status (_deleted) are required.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @return ApiBulkDocsRequest
*/
func (a *DatabaseApiService) BulkDocs(ctx context.Context, db string) ApiBulkDocsRequest {
	return ApiBulkDocsRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
	}
}

// Execute executes the request
//  @return []BulkResponse
func (a *DatabaseApiService) BulkDocsExecute(r ApiBulkDocsRequest) ([]BulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseApiService.BulkDocs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_bulk_docs"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkGetRequest struct {
	ctx context.Context
	ApiService DatabaseApi
	db string
	body *Body2
	revs *bool
}

// List of document objects, with id, and optionally rev and atts_since
func (r ApiBulkGetRequest) Body(body Body2) ApiBulkGetRequest {
	r.body = &body
	return r
}

// Give the revisions history
func (r ApiBulkGetRequest) Revs(revs bool) ApiBulkGetRequest {
	r.revs = &revs
	return r
}

func (r ApiBulkGetRequest) Execute() (*Results, *http.Response, error) {
	return r.ApiService.BulkGetExecute(r)
}

/*
BulkGet This method can be called to query several documents in bulk.

It is well suited for fetching a specific revision of documents, as replicators do for example, or for getting revision history.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @return ApiBulkGetRequest
*/
func (a *DatabaseApiService) BulkGet(ctx context.Context, db string) ApiBulkGetRequest {
	return ApiBulkGetRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
	}
}

// Execute executes the request
//  @return Results
func (a *DatabaseApiService) BulkGetExecute(r ApiBulkGetRequest) (*Results, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Results
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseApiService.BulkGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_bulk_get"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.revs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revs", r.revs, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/related", "multipart/mixed"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDbSecurityGetRequest struct {
	ctx context.Context
	ApiService DatabaseApi
	db string
}

func (r ApiDbSecurityGetRequest) Execute() (*InlineResponse2005, *http.Response, error) {
	return r.ApiService.DbSecurityGetExecute(r)
}

/*
DbSecurityGet Returns the current security object from the specified database.

The security object consists of two compulsory elements, admins and members, which are used to specify the list of users and/or roles that have admin and members rights to the database respectively:

  - members: they can read all types of documents from the DB, and they can write (and edit) documents to the DB except for design documents.
  - admins: they have all the privileges of members plus the privileges: write (and edit) design documents, add/remove database admins and members and set the database revisions limit. They can not create a database nor delete a database.

Both members and admins objects contain two array-typed fields:

  - names: List of CouchDB user names
  - roles: List of users roles

Any additional fields in the security object are optional. The entire security object is made available to validation and other internal functions so that the database can control and limit functionality.

If both the names and roles fields of either the admins or members properties are empty arrays, or are not existent, it means the database has no admins or members.

Having no admins, only server admins (with the reserved _admin role) are able to update design document and make other admin level changes.

Having no members, any user can write regular documents (any non-design document) and read documents from the database.

If there are any member names or roles defined for a database, then only authenticated users having a matching name or role are allowed to read documents from the database (or do a GET /{db} call).

*Note*
If the security object for a database has never been set, then the value returned will be empty.

Also note, that security objects are not regular versioned documents (that is, they are not under MVCC rules). This is a design choice to speed up authorization checks (avoids traversing a database’s documents B-Tree).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @return ApiDbSecurityGetRequest
*/
func (a *DatabaseApiService) DbSecurityGet(ctx context.Context, db string) ApiDbSecurityGetRequest {
	return ApiDbSecurityGetRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
	}
}

// Execute executes the request
//  @return InlineResponse2005
func (a *DatabaseApiService) DbSecurityGetExecute(r ApiDbSecurityGetRequest) (*InlineResponse2005, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse2005
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseApiService.DbSecurityGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_security"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plan"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRequest struct {
	ctx context.Context
	ApiService DatabaseApi
	db string
}

func (r ApiDeleteRequest) Execute() (*OK, *http.Response, error) {
	return r.ApiService.DeleteExecute(r)
}

/*
Delete Deletes the specified database, and all the documents and attachments contained within it.

*Note*
To avoid deleting a database, CouchDB will respond with the HTTP status code 400 when the request 
URL includes a ?rev= parameter. This suggests that one wants to delete a document but forgot to add 
the document id to the URL.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @return ApiDeleteRequest
*/
func (a *DatabaseApiService) Delete(ctx context.Context, db string) ApiDeleteRequest {
	return ApiDeleteRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
	}
}

// Execute executes the request
//  @return OK
func (a *DatabaseApiService) DeleteExecute(r ApiDeleteRequest) (*OK, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OK
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseApiService.Delete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDesignDocAllGetRequest struct {
	ctx context.Context
	ApiService DatabaseApi
	db string
	conflicts *bool
	descending *bool
	endkey *string
	endKey *string
	endkeyDocid *string
	endKeyDocId *string
	includeDocs *bool
	inclusiveEnd *bool
	key *string
	keys *string
	limit *int32
	skip *int32
	startkey *string
	startKey *string
	startkeyDocid *string
	startKeyDocId *string
	updateSeq *bool
}

// Include conflicts information in response. Ignored if include_docs isn’t true. Default is false.
func (r ApiDesignDocAllGetRequest) Conflicts(conflicts bool) ApiDesignDocAllGetRequest {
	r.conflicts = &conflicts
	return r
}

// Return the documents in descending order by key. Default is false.
func (r ApiDesignDocAllGetRequest) Descending(descending bool) ApiDesignDocAllGetRequest {
	r.descending = &descending
	return r
}

// Stop returning records when the specified key is reached. Optional.
func (r ApiDesignDocAllGetRequest) Endkey(endkey string) ApiDesignDocAllGetRequest {
	r.endkey = &endkey
	return r
}

// Alias for endkey param.
func (r ApiDesignDocAllGetRequest) EndKey(endKey string) ApiDesignDocAllGetRequest {
	r.endKey = &endKey
	return r
}

// Stop returning records when the specified design document ID is reached. Optional.
func (r ApiDesignDocAllGetRequest) EndkeyDocid(endkeyDocid string) ApiDesignDocAllGetRequest {
	r.endkeyDocid = &endkeyDocid
	return r
}

// Alias for endkey_docid param.
func (r ApiDesignDocAllGetRequest) EndKeyDocId(endKeyDocId string) ApiDesignDocAllGetRequest {
	r.endKeyDocId = &endKeyDocId
	return r
}

// Include the full content of the design documents in the return. Default is false.
func (r ApiDesignDocAllGetRequest) IncludeDocs(includeDocs bool) ApiDesignDocAllGetRequest {
	r.includeDocs = &includeDocs
	return r
}

// Specifies whether the specified end key should be included in the result. Default is true.
func (r ApiDesignDocAllGetRequest) InclusiveEnd(inclusiveEnd bool) ApiDesignDocAllGetRequest {
	r.inclusiveEnd = &inclusiveEnd
	return r
}

// Return only design documents that match the specified key. Optional.
func (r ApiDesignDocAllGetRequest) Key(key string) ApiDesignDocAllGetRequest {
	r.key = &key
	return r
}

// Return only design documents that match the specified keys. Optional.
func (r ApiDesignDocAllGetRequest) Keys(keys string) ApiDesignDocAllGetRequest {
	r.keys = &keys
	return r
}

// Limit the number of the returned design documents to the specified number. Optional.
func (r ApiDesignDocAllGetRequest) Limit(limit int32) ApiDesignDocAllGetRequest {
	r.limit = &limit
	return r
}

// Skip this number of records before starting to return the results. Default is 0.
func (r ApiDesignDocAllGetRequest) Skip(skip int32) ApiDesignDocAllGetRequest {
	r.skip = &skip
	return r
}

// Return records starting with the specified key. Optional.
func (r ApiDesignDocAllGetRequest) Startkey(startkey string) ApiDesignDocAllGetRequest {
	r.startkey = &startkey
	return r
}

// Alias for startkey param.
func (r ApiDesignDocAllGetRequest) StartKey(startKey string) ApiDesignDocAllGetRequest {
	r.startKey = &startKey
	return r
}

// Return records starting with the specified design document ID. Optional.
func (r ApiDesignDocAllGetRequest) StartkeyDocid(startkeyDocid string) ApiDesignDocAllGetRequest {
	r.startkeyDocid = &startkeyDocid
	return r
}

// Alias for startkey_docid param
func (r ApiDesignDocAllGetRequest) StartKeyDocId(startKeyDocId string) ApiDesignDocAllGetRequest {
	r.startKeyDocId = &startKeyDocId
	return r
}

// Whether to include in the response an update_seq value indicating the sequence id of the database the view reflects. Default is false.
func (r ApiDesignDocAllGetRequest) UpdateSeq(updateSeq bool) ApiDesignDocAllGetRequest {
	r.updateSeq = &updateSeq
	return r
}

func (r ApiDesignDocAllGetRequest) Execute() (*Pagination, *http.Response, error) {
	return r.ApiService.DesignDocAllGetExecute(r)
}

/*
DesignDocAllGet Returns a JSON structure of all of the design documents in a given database.

The information is returned as a JSON structure containing meta information about the return structure, including a list of all design documents and basic contents, consisting the ID, revision and key. The key is the design document’s _id.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @return ApiDesignDocAllGetRequest
*/
func (a *DatabaseApiService) DesignDocAllGet(ctx context.Context, db string) ApiDesignDocAllGetRequest {
	return ApiDesignDocAllGetRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
	}
}

// Execute executes the request
//  @return Pagination
func (a *DatabaseApiService) DesignDocAllGetExecute(r ApiDesignDocAllGetRequest) (*Pagination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Pagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseApiService.DesignDocAllGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_design_docs"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.conflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicts", r.conflicts, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.endkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endkey", r.endkey, "")
	}
	if r.endKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_key", r.endKey, "")
	}
	if r.endkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endkey_docid", r.endkeyDocid, "")
	}
	if r.endKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_key_doc_id", r.endKeyDocId, "")
	}
	if r.includeDocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_docs", r.includeDocs, "")
	}
	if r.inclusiveEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclusive_end", r.inclusiveEnd, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.keys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keys", r.keys, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "")
	}
	if r.startkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey", r.startkey, "")
	}
	if r.startKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key", r.startKey, "")
	}
	if r.startkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey_docid", r.startkeyDocid, "")
	}
	if r.startKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key_doc_id", r.startKeyDocId, "")
	}
	if r.updateSeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_seq", r.updateSeq, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plan"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDesignDocAllPostRequest struct {
	ctx context.Context
	ApiService DatabaseApi
	db string
	body *Body4
	conflicts *bool
	descending *bool
	endkey *string
	endKey *string
	endkeyDocid *string
	endKeyDocId *string
	includeDocs *bool
	inclusiveEnd *bool
	key *string
	keys *string
	limit *int32
	skip *int32
	startkey *string
	startKey *string
	startkeyDocid *string
	startKeyDocId *string
	updateSeq *bool
}

func (r ApiDesignDocAllPostRequest) Body(body Body4) ApiDesignDocAllPostRequest {
	r.body = &body
	return r
}

// Include conflicts information in response. Ignored if include_docs isn’t true. Default is false.
func (r ApiDesignDocAllPostRequest) Conflicts(conflicts bool) ApiDesignDocAllPostRequest {
	r.conflicts = &conflicts
	return r
}

// Return the documents in descending order by key. Default is false.
func (r ApiDesignDocAllPostRequest) Descending(descending bool) ApiDesignDocAllPostRequest {
	r.descending = &descending
	return r
}

// Stop returning records when the specified key is reached. Optional.
func (r ApiDesignDocAllPostRequest) Endkey(endkey string) ApiDesignDocAllPostRequest {
	r.endkey = &endkey
	return r
}

// Alias for endkey param.
func (r ApiDesignDocAllPostRequest) EndKey(endKey string) ApiDesignDocAllPostRequest {
	r.endKey = &endKey
	return r
}

// Stop returning records when the specified design document ID is reached. Optional.
func (r ApiDesignDocAllPostRequest) EndkeyDocid(endkeyDocid string) ApiDesignDocAllPostRequest {
	r.endkeyDocid = &endkeyDocid
	return r
}

// Alias for endkey_docid param.
func (r ApiDesignDocAllPostRequest) EndKeyDocId(endKeyDocId string) ApiDesignDocAllPostRequest {
	r.endKeyDocId = &endKeyDocId
	return r
}

// Include the full content of the design documents in the return. Default is false.
func (r ApiDesignDocAllPostRequest) IncludeDocs(includeDocs bool) ApiDesignDocAllPostRequest {
	r.includeDocs = &includeDocs
	return r
}

// Specifies whether the specified end key should be included in the result. Default is true.
func (r ApiDesignDocAllPostRequest) InclusiveEnd(inclusiveEnd bool) ApiDesignDocAllPostRequest {
	r.inclusiveEnd = &inclusiveEnd
	return r
}

// Return only design documents that match the specified key. Optional.
func (r ApiDesignDocAllPostRequest) Key(key string) ApiDesignDocAllPostRequest {
	r.key = &key
	return r
}

// Return only design documents that match the specified keys. Optional.
func (r ApiDesignDocAllPostRequest) Keys(keys string) ApiDesignDocAllPostRequest {
	r.keys = &keys
	return r
}

// Limit the number of the returned design documents to the specified number. Optional.
func (r ApiDesignDocAllPostRequest) Limit(limit int32) ApiDesignDocAllPostRequest {
	r.limit = &limit
	return r
}

// Skip this number of records before starting to return the results. Default is 0.
func (r ApiDesignDocAllPostRequest) Skip(skip int32) ApiDesignDocAllPostRequest {
	r.skip = &skip
	return r
}

// Return records starting with the specified key. Optional.
func (r ApiDesignDocAllPostRequest) Startkey(startkey string) ApiDesignDocAllPostRequest {
	r.startkey = &startkey
	return r
}

// Alias for startkey param.
func (r ApiDesignDocAllPostRequest) StartKey(startKey string) ApiDesignDocAllPostRequest {
	r.startKey = &startKey
	return r
}

// Return records starting with the specified design document ID. Optional.
func (r ApiDesignDocAllPostRequest) StartkeyDocid(startkeyDocid string) ApiDesignDocAllPostRequest {
	r.startkeyDocid = &startkeyDocid
	return r
}

// Alias for startkey_docid param
func (r ApiDesignDocAllPostRequest) StartKeyDocId(startKeyDocId string) ApiDesignDocAllPostRequest {
	r.startKeyDocId = &startKeyDocId
	return r
}

// Whether to include in the response an update_seq value indicating the sequence id of the database the view reflects. Default is false.
func (r ApiDesignDocAllPostRequest) UpdateSeq(updateSeq bool) ApiDesignDocAllPostRequest {
	r.updateSeq = &updateSeq
	return r
}

func (r ApiDesignDocAllPostRequest) Execute() (*Pagination, *http.Response, error) {
	return r.ApiService.DesignDocAllPostExecute(r)
}

/*
DesignDocAllPost POST _design_docs functionality supports identical parameters and behavior as specified in the GET /{db}/_design_docs

API but allows for the query string parameters to be supplied as keys in a JSON object in the body of the POST request.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @return ApiDesignDocAllPostRequest
*/
func (a *DatabaseApiService) DesignDocAllPost(ctx context.Context, db string) ApiDesignDocAllPostRequest {
	return ApiDesignDocAllPostRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
	}
}

// Execute executes the request
//  @return Pagination
func (a *DatabaseApiService) DesignDocAllPostExecute(r ApiDesignDocAllPostRequest) (*Pagination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Pagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseApiService.DesignDocAllPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_design_docs"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.conflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicts", r.conflicts, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.endkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endkey", r.endkey, "")
	}
	if r.endKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_key", r.endKey, "")
	}
	if r.endkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endkey_docid", r.endkeyDocid, "")
	}
	if r.endKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_key_doc_id", r.endKeyDocId, "")
	}
	if r.includeDocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_docs", r.includeDocs, "")
	}
	if r.inclusiveEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclusive_end", r.inclusiveEnd, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.keys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keys", r.keys, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "")
	}
	if r.startkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey", r.startkey, "")
	}
	if r.startKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key", r.startKey, "")
	}
	if r.startkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey_docid", r.startkeyDocid, "")
	}
	if r.startKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key_doc_id", r.startKeyDocId, "")
	}
	if r.updateSeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_seq", r.updateSeq, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/plan"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plan"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocGetAllRequest struct {
	ctx context.Context
	ApiService DatabaseApi
	db string
	conflicts *bool
	descending *bool
	endkey *string
	endKey *string
	endkeyDocid *string
	endKeyDocId *string
	group *bool
	groupLevel *int32
	includeDocs *bool
	attachments *bool
	attEncodingInfo *bool
	inclusiveEnd *bool
	revsInfo *bool
	key *string
	keys *[]string
	limit *int32
	reduce *bool
	skip *int32
	sorted *bool
	stable *bool
	stale *string
	startkey *string
	startKey *string
	startkeyDocid *string
	startKeyDocId *string
	update *string
	updateSeq *bool
}

// Include conflicts information in response. Ignored if include_docs isn’t true. Default is false.
func (r ApiDocGetAllRequest) Conflicts(conflicts bool) ApiDocGetAllRequest {
	r.conflicts = &conflicts
	return r
}

// Return the documents in descending order by key. Default is false.
func (r ApiDocGetAllRequest) Descending(descending bool) ApiDocGetAllRequest {
	r.descending = &descending
	return r
}

// Stop returning records when the specified key is reached.
func (r ApiDocGetAllRequest) Endkey(endkey string) ApiDocGetAllRequest {
	r.endkey = &endkey
	return r
}

// Alias for endkey param
func (r ApiDocGetAllRequest) EndKey(endKey string) ApiDocGetAllRequest {
	r.endKey = &endKey
	return r
}

// Stop returning records when the specified document ID is reached. Ignored if endkey is not set.
func (r ApiDocGetAllRequest) EndkeyDocid(endkeyDocid string) ApiDocGetAllRequest {
	r.endkeyDocid = &endkeyDocid
	return r
}

// Alias for endkey_docid.
func (r ApiDocGetAllRequest) EndKeyDocId(endKeyDocId string) ApiDocGetAllRequest {
	r.endKeyDocId = &endKeyDocId
	return r
}

// Group the results using the reduce function to a group or single row. Implies reduce is true and the maximum group_level. Default is false.
func (r ApiDocGetAllRequest) Group(group bool) ApiDocGetAllRequest {
	r.group = &group
	return r
}

// Specify the group level to be used. Implies group is true.
func (r ApiDocGetAllRequest) GroupLevel(groupLevel int32) ApiDocGetAllRequest {
	r.groupLevel = &groupLevel
	return r
}

// Include the associated document with each row. Default is false.
func (r ApiDocGetAllRequest) IncludeDocs(includeDocs bool) ApiDocGetAllRequest {
	r.includeDocs = &includeDocs
	return r
}

// Include the Base64-encoded content of attachments in the documents that are included if include_docs is true. Ignored if include_docs isn’t true. Default is false.
func (r ApiDocGetAllRequest) Attachments(attachments bool) ApiDocGetAllRequest {
	r.attachments = &attachments
	return r
}

// Include encoding information in attachment stubs if include_docs is true and the particular attachment is compressed. Ignored if include_docs isn’t true. Default is false.
func (r ApiDocGetAllRequest) AttEncodingInfo(attEncodingInfo bool) ApiDocGetAllRequest {
	r.attEncodingInfo = &attEncodingInfo
	return r
}

// Specifies whether the specified end key should be included in the result. Default is true.
func (r ApiDocGetAllRequest) InclusiveEnd(inclusiveEnd bool) ApiDocGetAllRequest {
	r.inclusiveEnd = &inclusiveEnd
	return r
}

// Includes detailed information for all known document revisions. Default is false
func (r ApiDocGetAllRequest) RevsInfo(revsInfo bool) ApiDocGetAllRequest {
	r.revsInfo = &revsInfo
	return r
}

// eturn only documents that match the specified key.
func (r ApiDocGetAllRequest) Key(key string) ApiDocGetAllRequest {
	r.key = &key
	return r
}

// Return only documents where the key matches one of the keys specified in the array.
func (r ApiDocGetAllRequest) Keys(keys []string) ApiDocGetAllRequest {
	r.keys = &keys
	return r
}

// Limit the number of the returned documents to the specified number.
func (r ApiDocGetAllRequest) Limit(limit int32) ApiDocGetAllRequest {
	r.limit = &limit
	return r
}

// Use the reduction function. Default is true when a reduce function is defined.
func (r ApiDocGetAllRequest) Reduce(reduce bool) ApiDocGetAllRequest {
	r.reduce = &reduce
	return r
}

// Skip this number of records before starting to return the results. Default is 0.
func (r ApiDocGetAllRequest) Skip(skip int32) ApiDocGetAllRequest {
	r.skip = &skip
	return r
}

// Sort returned rows (see Sorting Returned Rows). Setting this to false offers a performance boost. The total_rows and offset fields are not available when this is set to false. Default is true.
func (r ApiDocGetAllRequest) Sorted(sorted bool) ApiDocGetAllRequest {
	r.sorted = &sorted
	return r
}

// Whether or not the view results should be returned from a stable set of shards. Default is false.
func (r ApiDocGetAllRequest) Stable(stable bool) ApiDocGetAllRequest {
	r.stable = &stable
	return r
}

// Allow the results from a stale view to be used. Supported values: ok and update_after. ok is equivalent to stable&#x3D;true&amp;update&#x3D;false. update_after is equivalent to stable&#x3D;true&amp;update&#x3D;lazy. The default behavior is equivalent to stable&#x3D;false&amp;update&#x3D;true. Note that this parameter is deprecated. Use stable and update instead. See Views Generation for more details. 
func (r ApiDocGetAllRequest) Stale(stale string) ApiDocGetAllRequest {
	r.stale = &stale
	return r
}

// Return records starting with the specified key.
func (r ApiDocGetAllRequest) Startkey(startkey string) ApiDocGetAllRequest {
	r.startkey = &startkey
	return r
}

// Alias for startkey.
func (r ApiDocGetAllRequest) StartKey(startKey string) ApiDocGetAllRequest {
	r.startKey = &startKey
	return r
}

// Return records starting with the specified document ID. Ignored if startkey is not set.
func (r ApiDocGetAllRequest) StartkeyDocid(startkeyDocid string) ApiDocGetAllRequest {
	r.startkeyDocid = &startkeyDocid
	return r
}

// Alias for startkey_docid param
func (r ApiDocGetAllRequest) StartKeyDocId(startKeyDocId string) ApiDocGetAllRequest {
	r.startKeyDocId = &startKeyDocId
	return r
}

// Whether or not the view in question should be updated prior to responding to the user. Supported values: true, false, lazy. Default is true. 
func (r ApiDocGetAllRequest) Update(update string) ApiDocGetAllRequest {
	r.update = &update
	return r
}

// Whether to include in the response an update_seq value indicating the sequence id of the database the view reflects. Default is false.
func (r ApiDocGetAllRequest) UpdateSeq(updateSeq bool) ApiDocGetAllRequest {
	r.updateSeq = &updateSeq
	return r
}

func (r ApiDocGetAllRequest) Execute() (*Pagination, *http.Response, error) {
	return r.ApiService.DocGetAllExecute(r)
}

/*
DocGetAll Executes the built-in _all_docs view

returning all of the documents in the database. With the exception of the URL parameters 
(described below), this endpoint works identically to any other view. Refer to the view endpoint 
documentation for a complete description of the available query parameters and the format of 
the returned data.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @return ApiDocGetAllRequest
*/
func (a *DatabaseApiService) DocGetAll(ctx context.Context, db string) ApiDocGetAllRequest {
	return ApiDocGetAllRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
	}
}

// Execute executes the request
//  @return Pagination
func (a *DatabaseApiService) DocGetAllExecute(r ApiDocGetAllRequest) (*Pagination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Pagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseApiService.DocGetAll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_all_docs"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.conflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicts", r.conflicts, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.endkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endkey", r.endkey, "")
	}
	if r.endKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_key", r.endKey, "")
	}
	if r.endkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endkey_docid", r.endkeyDocid, "")
	}
	if r.endKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_key_doc_id", r.endKeyDocId, "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.groupLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_level", r.groupLevel, "")
	}
	if r.includeDocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_docs", r.includeDocs, "")
	}
	if r.attachments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachments", r.attachments, "")
	}
	if r.attEncodingInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "att_encoding_info", r.attEncodingInfo, "")
	}
	if r.inclusiveEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclusive_end", r.inclusiveEnd, "")
	}
	if r.revsInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revs_info", r.revsInfo, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.keys != nil {
		t := *r.keys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "keys", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "keys", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.reduce != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reduce", r.reduce, "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "")
	}
	if r.sorted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sorted", r.sorted, "")
	}
	if r.stable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stable", r.stable, "")
	}
	if r.stale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stale", r.stale, "")
	}
	if r.startkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey", r.startkey, "")
	}
	if r.startKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key", r.startKey, "")
	}
	if r.startkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey_docid", r.startkeyDocid, "")
	}
	if r.startKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key_doc_id", r.startKeyDocId, "")
	}
	if r.update != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update", r.update, "")
	}
	if r.updateSeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_seq", r.updateSeq, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocPostAllRequest struct {
	ctx context.Context
	ApiService DatabaseApi
	db string
	body *Keys
	conflicts *bool
	descending *bool
	endkey *string
	endKey *string
	endkeyDocid *string
	endKeyDocId *string
	group *bool
	groupLevel *int32
	includeDocs *bool
	attachments *bool
	attEncodingInfo *bool
	inclusiveEnd *bool
	revsInfo *bool
	key *string
	keys *[]string
	limit *int32
	reduce *bool
	skip *int32
	sorted *bool
	stable *bool
	stale *string
	startkey *string
	startKey *string
	startkeyDocid *string
	startKeyDocId *string
	update *string
	updateSeq *bool
}

func (r ApiDocPostAllRequest) Body(body Keys) ApiDocPostAllRequest {
	r.body = &body
	return r
}

// Include conflicts information in response. Ignored if include_docs isn’t true. Default is false.
func (r ApiDocPostAllRequest) Conflicts(conflicts bool) ApiDocPostAllRequest {
	r.conflicts = &conflicts
	return r
}

// Return the documents in descending order by key. Default is false.
func (r ApiDocPostAllRequest) Descending(descending bool) ApiDocPostAllRequest {
	r.descending = &descending
	return r
}

// Stop returning records when the specified key is reached.
func (r ApiDocPostAllRequest) Endkey(endkey string) ApiDocPostAllRequest {
	r.endkey = &endkey
	return r
}

// Alias for endkey param
func (r ApiDocPostAllRequest) EndKey(endKey string) ApiDocPostAllRequest {
	r.endKey = &endKey
	return r
}

// Stop returning records when the specified document ID is reached. Ignored if endkey is not set.
func (r ApiDocPostAllRequest) EndkeyDocid(endkeyDocid string) ApiDocPostAllRequest {
	r.endkeyDocid = &endkeyDocid
	return r
}

// Alias for endkey_docid.
func (r ApiDocPostAllRequest) EndKeyDocId(endKeyDocId string) ApiDocPostAllRequest {
	r.endKeyDocId = &endKeyDocId
	return r
}

// Group the results using the reduce function to a group or single row. Implies reduce is true and the maximum group_level. Default is false.
func (r ApiDocPostAllRequest) Group(group bool) ApiDocPostAllRequest {
	r.group = &group
	return r
}

// Specify the group level to be used. Implies group is true.
func (r ApiDocPostAllRequest) GroupLevel(groupLevel int32) ApiDocPostAllRequest {
	r.groupLevel = &groupLevel
	return r
}

// Include the associated document with each row. Default is false.
func (r ApiDocPostAllRequest) IncludeDocs(includeDocs bool) ApiDocPostAllRequest {
	r.includeDocs = &includeDocs
	return r
}

// Include the Base64-encoded content of attachments in the documents that are included if include_docs is true. Ignored if include_docs isn’t true. Default is false.
func (r ApiDocPostAllRequest) Attachments(attachments bool) ApiDocPostAllRequest {
	r.attachments = &attachments
	return r
}

// Include encoding information in attachment stubs if include_docs is true and the particular attachment is compressed. Ignored if include_docs isn’t true. Default is false.
func (r ApiDocPostAllRequest) AttEncodingInfo(attEncodingInfo bool) ApiDocPostAllRequest {
	r.attEncodingInfo = &attEncodingInfo
	return r
}

// Specifies whether the specified end key should be included in the result. Default is true.
func (r ApiDocPostAllRequest) InclusiveEnd(inclusiveEnd bool) ApiDocPostAllRequest {
	r.inclusiveEnd = &inclusiveEnd
	return r
}

// Includes detailed information for all known document revisions. Default is false
func (r ApiDocPostAllRequest) RevsInfo(revsInfo bool) ApiDocPostAllRequest {
	r.revsInfo = &revsInfo
	return r
}

// eturn only documents that match the specified key.
func (r ApiDocPostAllRequest) Key(key string) ApiDocPostAllRequest {
	r.key = &key
	return r
}

// Return only documents where the key matches one of the keys specified in the array.
func (r ApiDocPostAllRequest) Keys(keys []string) ApiDocPostAllRequest {
	r.keys = &keys
	return r
}

// Limit the number of the returned documents to the specified number.
func (r ApiDocPostAllRequest) Limit(limit int32) ApiDocPostAllRequest {
	r.limit = &limit
	return r
}

// Use the reduction function. Default is true when a reduce function is defined.
func (r ApiDocPostAllRequest) Reduce(reduce bool) ApiDocPostAllRequest {
	r.reduce = &reduce
	return r
}

// Skip this number of records before starting to return the results. Default is 0.
func (r ApiDocPostAllRequest) Skip(skip int32) ApiDocPostAllRequest {
	r.skip = &skip
	return r
}

// Sort returned rows (see Sorting Returned Rows). Setting this to false offers a performance boost. The total_rows and offset fields are not available when this is set to false. Default is true.
func (r ApiDocPostAllRequest) Sorted(sorted bool) ApiDocPostAllRequest {
	r.sorted = &sorted
	return r
}

// Whether or not the view results should be returned from a stable set of shards. Default is false.
func (r ApiDocPostAllRequest) Stable(stable bool) ApiDocPostAllRequest {
	r.stable = &stable
	return r
}

// Allow the results from a stale view to be used. Supported values: ok and update_after. ok is equivalent to stable&#x3D;true&amp;update&#x3D;false. update_after is equivalent to stable&#x3D;true&amp;update&#x3D;lazy. The default behavior is equivalent to stable&#x3D;false&amp;update&#x3D;true. Note that this parameter is deprecated. Use stable and update instead. See Views Generation for more details. 
func (r ApiDocPostAllRequest) Stale(stale string) ApiDocPostAllRequest {
	r.stale = &stale
	return r
}

// Return records starting with the specified key.
func (r ApiDocPostAllRequest) Startkey(startkey string) ApiDocPostAllRequest {
	r.startkey = &startkey
	return r
}

// Alias for startkey.
func (r ApiDocPostAllRequest) StartKey(startKey string) ApiDocPostAllRequest {
	r.startKey = &startKey
	return r
}

// Return records starting with the specified document ID. Ignored if startkey is not set.
func (r ApiDocPostAllRequest) StartkeyDocid(startkeyDocid string) ApiDocPostAllRequest {
	r.startkeyDocid = &startkeyDocid
	return r
}

// Alias for startkey_docid param
func (r ApiDocPostAllRequest) StartKeyDocId(startKeyDocId string) ApiDocPostAllRequest {
	r.startKeyDocId = &startKeyDocId
	return r
}

// Whether or not the view in question should be updated prior to responding to the user. Supported values: true, false, lazy. Default is true. 
func (r ApiDocPostAllRequest) Update(update string) ApiDocPostAllRequest {
	r.update = &update
	return r
}

// Whether to include in the response an update_seq value indicating the sequence id of the database the view reflects. Default is false.
func (r ApiDocPostAllRequest) UpdateSeq(updateSeq bool) ApiDocPostAllRequest {
	r.updateSeq = &updateSeq
	return r
}

func (r ApiDocPostAllRequest) Execute() (*Pagination, *http.Response, error) {
	return r.ApiService.DocPostAllExecute(r)
}

/*
DocPostAll Executes the built-in _all_docs view

POST _all_docs functionality supports identical parameters and behavior as specified in the 
GET /{db}/_all_docs API but allows for the query string parameters to be supplied as keys in a 
JSON object in the body of the POST request.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @return ApiDocPostAllRequest
*/
func (a *DatabaseApiService) DocPostAll(ctx context.Context, db string) ApiDocPostAllRequest {
	return ApiDocPostAllRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
	}
}

// Execute executes the request
//  @return Pagination
func (a *DatabaseApiService) DocPostAllExecute(r ApiDocPostAllRequest) (*Pagination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Pagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseApiService.DocPostAll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_all_docs"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.conflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicts", r.conflicts, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.endkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endkey", r.endkey, "")
	}
	if r.endKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_key", r.endKey, "")
	}
	if r.endkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endkey_docid", r.endkeyDocid, "")
	}
	if r.endKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_key_doc_id", r.endKeyDocId, "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.groupLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_level", r.groupLevel, "")
	}
	if r.includeDocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_docs", r.includeDocs, "")
	}
	if r.attachments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachments", r.attachments, "")
	}
	if r.attEncodingInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "att_encoding_info", r.attEncodingInfo, "")
	}
	if r.inclusiveEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclusive_end", r.inclusiveEnd, "")
	}
	if r.revsInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revs_info", r.revsInfo, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.keys != nil {
		t := *r.keys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "keys", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "keys", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.reduce != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reduce", r.reduce, "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "")
	}
	if r.sorted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sorted", r.sorted, "")
	}
	if r.stable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stable", r.stable, "")
	}
	if r.stale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stale", r.stale, "")
	}
	if r.startkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey", r.startkey, "")
	}
	if r.startKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key", r.startKey, "")
	}
	if r.startkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey_docid", r.startkeyDocid, "")
	}
	if r.startKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key_doc_id", r.startKeyDocId, "")
	}
	if r.update != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update", r.update, "")
	}
	if r.updateSeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_seq", r.updateSeq, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExistsRequest struct {
	ctx context.Context
	ApiService DatabaseApi
	db string
}

func (r ApiExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ExistsExecute(r)
}

/*
Exists Returns the HTTP Headers containing a minimal amount of information about the specified database.

Since the response body is empty, using the HEAD method is a lightweight way to check if the database exists already or not.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @return ApiExistsRequest
*/
func (a *DatabaseApiService) Exists(ctx context.Context, db string) ApiExistsRequest {
	return ApiExistsRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
	}
}

// Execute executes the request
func (a *DatabaseApiService) ExistsExecute(r ApiExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseApiService.Exists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRequest struct {
	ctx context.Context
	ApiService DatabaseApi
	db string
}

func (r ApiGetRequest) Execute() (*Database, *http.Response, error) {
	return r.ApiService.GetExecute(r)
}

/*
Get Gets information about the specified database.

By passing in the appropriate options, you can search for
available inventory in the system


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @return ApiGetRequest
*/
func (a *DatabaseApiService) Get(ctx context.Context, db string) ApiGetRequest {
	return ApiGetRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
	}
}

// Execute executes the request
//  @return Database
func (a *DatabaseApiService) GetExecute(r ApiGetRequest) (*Database, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Database
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseApiService.Get")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutRequest struct {
	ctx context.Context
	ApiService DatabaseApi
	db string
	q *int32
	n *int32
	partitioned *bool
}

// Shards, aka the number of range partitions. Default is 8, unless overridden in the cluster config.
func (r ApiPutRequest) Q(q int32) ApiPutRequest {
	r.q = &q
	return r
}

// Replicas. The number of copies of the database in the cluster. The default is 3, unless overridden in the cluster config .
func (r ApiPutRequest) N(n int32) ApiPutRequest {
	r.n = &n
	return r
}

// Whether to create a partitioned database. Default is false.
func (r ApiPutRequest) Partitioned(partitioned bool) ApiPutRequest {
	r.partitioned = &partitioned
	return r
}

func (r ApiPutRequest) Execute() (*OK, *http.Response, error) {
	return r.ApiService.PutExecute(r)
}

/*
Put Creates a new database.

The database name {db} must be composed by following next rules:
Name must begin with a lowercase letter (a-z)
* Lowercase characters (a-z)
* Digits (0-9)
* Any of the characters _, $, (, ), +, -, and /.

If you’re familiar with Regular Expressions, the rules above could be written as 


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @return ApiPutRequest
*/
func (a *DatabaseApiService) Put(ctx context.Context, db string) ApiPutRequest {
	return ApiPutRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
	}
}

// Execute executes the request
//  @return OK
func (a *DatabaseApiService) PutExecute(r ApiPutRequest) (*OK, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OK
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseApiService.Put")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.n != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "n", r.n, "")
	}
	if r.partitioned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partitioned", r.partitioned, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSbSecurityPutRequest struct {
	ctx context.Context
	ApiService DatabaseApi
	db string
	body *Body5
}

func (r ApiSbSecurityPutRequest) Body(body Body5) ApiSbSecurityPutRequest {
	r.body = &body
	return r
}

func (r ApiSbSecurityPutRequest) Execute() (*OK, *http.Response, error) {
	return r.ApiService.SbSecurityPutExecute(r)
}

/*
SbSecurityPut Sets the security object for the given database.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @return ApiSbSecurityPutRequest
*/
func (a *DatabaseApiService) SbSecurityPut(ctx context.Context, db string) ApiSbSecurityPutRequest {
	return ApiSbSecurityPutRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
	}
}

// Execute executes the request
//  @return OK
func (a *DatabaseApiService) SbSecurityPutExecute(r ApiSbSecurityPutRequest) (*OK, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OK
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseApiService.SbSecurityPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_security"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/plan"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plan"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
