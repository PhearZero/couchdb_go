/*
CouchDB API

*Note* This is not a definitive implementation of the CouchDB API, it's missing a lot of the endpoints for server/database managment and everything for attachments all COPY operations and probably a few other parts.  It also targets golang, as such the '#/definitions/Document' is intentionally left empty to generate a go `interface`, which you can then cast to a `map[string]interface{}`. 

API version: 4.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package couchdb_go

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type DesignDocumentsApi interface {

	/*
	DesignDocDelete Deletes the specified document from the database. You must supply the current (latest) revision, either by using the rev parameter to specify the revision.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@param ddoc Design document id
	@return ApiDesignDocDeleteRequest
	*/
	DesignDocDelete(ctx context.Context, db string, ddoc string) ApiDesignDocDeleteRequest

	// DesignDocDeleteExecute executes the request
	//  @return DocumentOK
	DesignDocDeleteExecute(r ApiDesignDocDeleteRequest) (*DocumentOK, *http.Response, error)

	/*
	DesignDocExists Returns the HTTP Headers containing a minimal amount of information about the specified design document.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@param ddoc Design document id
	@return ApiDesignDocExistsRequest
	*/
	DesignDocExists(ctx context.Context, db string, ddoc string) ApiDesignDocExistsRequest

	// DesignDocExistsExecute executes the request
	DesignDocExistsExecute(r ApiDesignDocExistsRequest) (*http.Response, error)

	/*
	DesignDocGet Returns the contents of the design document specified with the name of the design document and from the specified database from the URL.

	Unless you request a specific revision, the latest revision of the document will always be returned.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@param ddoc Design document id
	@return ApiDesignDocGetRequest
	*/
	DesignDocGet(ctx context.Context, db string, ddoc string) ApiDesignDocGetRequest

	// DesignDocGetExecute executes the request
	//  @return DesignDoc
	DesignDocGetExecute(r ApiDesignDocGetRequest) (*DesignDoc, *http.Response, error)

	/*
	DesignDocInfo Obtains information about the specified design document, including the index, index size and current status of the design document and associated index information.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@param ddoc Design document id
	@return ApiDesignDocInfoRequest
	*/
	DesignDocInfo(ctx context.Context, db string, ddoc string) ApiDesignDocInfoRequest

	// DesignDocInfoExecute executes the request
	//  @return InlineResponse2007
	DesignDocInfoExecute(r ApiDesignDocInfoRequest) (*InlineResponse2007, *http.Response, error)

	/*
	DesignDocPut The PUT method creates a new named design document, or creates a new revision of the existing design document.

	*Note*
that for filters, lists, shows and updates fields objects are mapping of function name to string function source code. For views mapping is the same except that values are objects with map and reduce (optional) keys which also contains functions source code.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@param ddoc Design document id
	@return ApiDesignDocPutRequest
	*/
	DesignDocPut(ctx context.Context, db string, ddoc string) ApiDesignDocPutRequest

	// DesignDocPutExecute executes the request
	//  @return DocumentOK
	DesignDocPutExecute(r ApiDesignDocPutRequest) (*DocumentOK, *http.Response, error)

	/*
	DesignDocSearch Executes a search request against the named index in the specified design document.

	*Warning*
Search endpoints require a running search plugin connected to each cluster node. See Search Plugin Installation for details.

*Note*
You must enable faceting before you can use the counts, drilldown, and ranges parameters.

*Note*
Faceting and grouping are not supported on partitioned searches, so the following query parameters should not be used on those requests: counts, drilldown, ranges, and group_field, group_limit, group_sort``.

*Note*        
Do not combine the bookmark and stale options. These options constrain the choice of shard replicas to use for the response. When used together, the options might cause problems when contact is attempted with replicas that are slow or not available.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@param ddoc Design document id
	@param index Search index name
	@return ApiDesignDocSearchRequest
	*/
	DesignDocSearch(ctx context.Context, db string, ddoc string, index string) ApiDesignDocSearchRequest

	// DesignDocSearchExecute executes the request
	//  @return Pagination
	DesignDocSearchExecute(r ApiDesignDocSearchRequest) (*Pagination, *http.Response, error)

	/*
	DesignDocSearchInfo Executes a search request against the named index in the specified design document.

	*Warning*
Search endpoints require a running search plugin connected to each cluster node. See Search Plugin Installation for details.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@param ddoc Design document id
	@param index Search index name
	@return ApiDesignDocSearchInfoRequest
	*/
	DesignDocSearchInfo(ctx context.Context, db string, ddoc string, index string) ApiDesignDocSearchInfoRequest

	// DesignDocSearchInfoExecute executes the request
	//  @return InlineResponse2008
	DesignDocSearchInfoExecute(r ApiDesignDocSearchInfoRequest) (*InlineResponse2008, *http.Response, error)

	/*
	DesignDocView Executes the specified view function from the specified design document.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@param ddoc Design document id
	@param view View function name
	@return ApiDesignDocViewRequest
	*/
	DesignDocView(ctx context.Context, db string, ddoc string, view string) ApiDesignDocViewRequest

	// DesignDocViewExecute executes the request
	//  @return Pagination
	DesignDocViewExecute(r ApiDesignDocViewRequest) (*Pagination, *http.Response, error)

	/*
	DesignDocViewPost Executes the specified view function from the specified design document.

	POST view functionality supports identical parameters and behavior as specified in the GET /{db}/_design/{ddoc}/_view/{view} API but allows for the query string parameters to be supplied as keys in a JSON object in the body of the POST request.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param db Database name
	@param ddoc Design document id
	@param view View function name
	@return ApiDesignDocViewPostRequest
	*/
	DesignDocViewPost(ctx context.Context, db string, ddoc string, view string) ApiDesignDocViewPostRequest

	// DesignDocViewPostExecute executes the request
	//  @return Pagination
	DesignDocViewPostExecute(r ApiDesignDocViewPostRequest) (*Pagination, *http.Response, error)
}

// DesignDocumentsApiService DesignDocumentsApi service
type DesignDocumentsApiService service

type ApiDesignDocDeleteRequest struct {
	ctx context.Context
	ApiService DesignDocumentsApi
	db string
	ddoc string
	ifMatch *string
	rev *string
	batch *string
}

// Document’s revision. Alternative to rev query parameter
func (r ApiDesignDocDeleteRequest) IfMatch(ifMatch string) ApiDesignDocDeleteRequest {
	r.ifMatch = &ifMatch
	return r
}

// Actual document’s revision
func (r ApiDesignDocDeleteRequest) Rev(rev string) ApiDesignDocDeleteRequest {
	r.rev = &rev
	return r
}

// Stores document in batch mode Possible values: ok. Optional 
func (r ApiDesignDocDeleteRequest) Batch(batch string) ApiDesignDocDeleteRequest {
	r.batch = &batch
	return r
}

func (r ApiDesignDocDeleteRequest) Execute() (*DocumentOK, *http.Response, error) {
	return r.ApiService.DesignDocDeleteExecute(r)
}

/*
DesignDocDelete Deletes the specified document from the database. You must supply the current (latest) revision, either by using the rev parameter to specify the revision.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param ddoc Design document id
 @return ApiDesignDocDeleteRequest
*/
func (a *DesignDocumentsApiService) DesignDocDelete(ctx context.Context, db string, ddoc string) ApiDesignDocDeleteRequest {
	return ApiDesignDocDeleteRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		ddoc: ddoc,
	}
}

// Execute executes the request
//  @return DocumentOK
func (a *DesignDocumentsApiService) DesignDocDeleteExecute(r ApiDesignDocDeleteRequest) (*DocumentOK, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DocumentOK
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DesignDocumentsApiService.DesignDocDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_design/{ddoc}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ddoc"+"}", url.PathEscape(parameterValueToString(r.ddoc, "ddoc")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.rev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rev", r.rev, "")
	}
	if r.batch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "batch", r.batch, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDesignDocExistsRequest struct {
	ctx context.Context
	ApiService DesignDocumentsApi
	db string
	ddoc string
}

func (r ApiDesignDocExistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DesignDocExistsExecute(r)
}

/*
DesignDocExists Returns the HTTP Headers containing a minimal amount of information about the specified design document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param ddoc Design document id
 @return ApiDesignDocExistsRequest
*/
func (a *DesignDocumentsApiService) DesignDocExists(ctx context.Context, db string, ddoc string) ApiDesignDocExistsRequest {
	return ApiDesignDocExistsRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		ddoc: ddoc,
	}
}

// Execute executes the request
func (a *DesignDocumentsApiService) DesignDocExistsExecute(r ApiDesignDocExistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DesignDocumentsApiService.DesignDocExists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_design/{ddoc}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ddoc"+"}", url.PathEscape(parameterValueToString(r.ddoc, "ddoc")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDesignDocGetRequest struct {
	ctx context.Context
	ApiService DesignDocumentsApi
	db string
	ddoc string
	ifNoneMatch *string
	attachments *bool
	attEncodingInfo *bool
	attsSince *[]string
	conflicts *bool
	deletedConflicts *bool
	latest *bool
	localSeq *bool
	meta *bool
	openRevs *[]string
	rev *string
	revs *bool
	revsInfo *bool
}

// Double quoted document’s revision token
func (r ApiDesignDocGetRequest) IfNoneMatch(ifNoneMatch string) ApiDesignDocGetRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// Includes attachments bodies in response. Default is false
func (r ApiDesignDocGetRequest) Attachments(attachments bool) ApiDesignDocGetRequest {
	r.attachments = &attachments
	return r
}

// Includes encoding information in attachment stubs if the particular attachment is compressed. Default is false.
func (r ApiDesignDocGetRequest) AttEncodingInfo(attEncodingInfo bool) ApiDesignDocGetRequest {
	r.attEncodingInfo = &attEncodingInfo
	return r
}

// Includes attachments only since specified revisions. Doesn’t includes attachments for specified revisions. Optional
func (r ApiDesignDocGetRequest) AttsSince(attsSince []string) ApiDesignDocGetRequest {
	r.attsSince = &attsSince
	return r
}

// Includes information about conflicts in document. Default is false
func (r ApiDesignDocGetRequest) Conflicts(conflicts bool) ApiDesignDocGetRequest {
	r.conflicts = &conflicts
	return r
}

// Includes information about deleted conflicted revisions. Default is false
func (r ApiDesignDocGetRequest) DeletedConflicts(deletedConflicts bool) ApiDesignDocGetRequest {
	r.deletedConflicts = &deletedConflicts
	return r
}

// Forces retrieving latest “leaf” revision, no matter what rev was requested. Default is false
func (r ApiDesignDocGetRequest) Latest(latest bool) ApiDesignDocGetRequest {
	r.latest = &latest
	return r
}

// Includes last update sequence for the document. Default is false
func (r ApiDesignDocGetRequest) LocalSeq(localSeq bool) ApiDesignDocGetRequest {
	r.localSeq = &localSeq
	return r
}

// Acts same as specifying all conflicts, deleted_conflicts and revs_info query parameters. Default is false
func (r ApiDesignDocGetRequest) Meta(meta bool) ApiDesignDocGetRequest {
	r.meta = &meta
	return r
}

// Retrieves documents of specified leaf revisions. Additionally, it accepts value as all to return all leaf revisions. Optional
func (r ApiDesignDocGetRequest) OpenRevs(openRevs []string) ApiDesignDocGetRequest {
	r.openRevs = &openRevs
	return r
}

// Retrieves document of specified revision. Optional
func (r ApiDesignDocGetRequest) Rev(rev string) ApiDesignDocGetRequest {
	r.rev = &rev
	return r
}

// Includes list of all known document revisions. Default is false
func (r ApiDesignDocGetRequest) Revs(revs bool) ApiDesignDocGetRequest {
	r.revs = &revs
	return r
}

// Includes detailed information for all known document revisions. Default is false
func (r ApiDesignDocGetRequest) RevsInfo(revsInfo bool) ApiDesignDocGetRequest {
	r.revsInfo = &revsInfo
	return r
}

func (r ApiDesignDocGetRequest) Execute() (*DesignDoc, *http.Response, error) {
	return r.ApiService.DesignDocGetExecute(r)
}

/*
DesignDocGet Returns the contents of the design document specified with the name of the design document and from the specified database from the URL.

Unless you request a specific revision, the latest revision of the document will always be returned.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param ddoc Design document id
 @return ApiDesignDocGetRequest
*/
func (a *DesignDocumentsApiService) DesignDocGet(ctx context.Context, db string, ddoc string) ApiDesignDocGetRequest {
	return ApiDesignDocGetRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		ddoc: ddoc,
	}
}

// Execute executes the request
//  @return DesignDoc
func (a *DesignDocumentsApiService) DesignDocGetExecute(r ApiDesignDocGetRequest) (*DesignDoc, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DesignDoc
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DesignDocumentsApiService.DesignDocGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_design/{ddoc}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ddoc"+"}", url.PathEscape(parameterValueToString(r.ddoc, "ddoc")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ifNoneMatch == nil {
		return localVarReturnValue, nil, reportError("ifNoneMatch is required and must be specified")
	}

	if r.attachments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachments", r.attachments, "")
	}
	if r.attEncodingInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "att_encoding_info", r.attEncodingInfo, "")
	}
	if r.attsSince != nil {
		t := *r.attsSince
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "atts_since", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "atts_since", t, "multi")
		}
	}
	if r.conflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicts", r.conflicts, "")
	}
	if r.deletedConflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deleted_conflicts", r.deletedConflicts, "")
	}
	if r.latest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latest", r.latest, "")
	}
	if r.localSeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "local_seq", r.localSeq, "")
	}
	if r.meta != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "meta", r.meta, "")
	}
	if r.openRevs != nil {
		t := *r.openRevs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "open_revs", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "open_revs", t, "multi")
		}
	}
	if r.rev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rev", r.rev, "")
	}
	if r.revs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revs", r.revs, "")
	}
	if r.revsInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revs_info", r.revsInfo, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "multipart/related", "multipart/mixed", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDesignDocInfoRequest struct {
	ctx context.Context
	ApiService DesignDocumentsApi
	db string
	ddoc string
}

func (r ApiDesignDocInfoRequest) Execute() (*InlineResponse2007, *http.Response, error) {
	return r.ApiService.DesignDocInfoExecute(r)
}

/*
DesignDocInfo Obtains information about the specified design document, including the index, index size and current status of the design document and associated index information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param ddoc Design document id
 @return ApiDesignDocInfoRequest
*/
func (a *DesignDocumentsApiService) DesignDocInfo(ctx context.Context, db string, ddoc string) ApiDesignDocInfoRequest {
	return ApiDesignDocInfoRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		ddoc: ddoc,
	}
}

// Execute executes the request
//  @return InlineResponse2007
func (a *DesignDocumentsApiService) DesignDocInfoExecute(r ApiDesignDocInfoRequest) (*InlineResponse2007, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse2007
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DesignDocumentsApiService.DesignDocInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_design/{ddoc}/_info"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ddoc"+"}", url.PathEscape(parameterValueToString(r.ddoc, "ddoc")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDesignDocPutRequest struct {
	ctx context.Context
	ApiService DesignDocumentsApi
	db string
	ddoc string
	body *DesignDoc
	ifMatch *string
	rev *string
	conflicts *bool
	descending *bool
	group *bool
	groupLevel *int32
	attachments *bool
	attEncodingInfo *bool
	inclusiveEnd *bool
	limit *int32
	reduce *bool
	skip *int32
	sorted *bool
	stable *bool
	stale *string
	startkeyDocid *string
	startKeyDocId *string
	update *string
	updateSeq *bool
}

func (r ApiDesignDocPutRequest) Body(body DesignDoc) ApiDesignDocPutRequest {
	r.body = &body
	return r
}

// Document’s revision. Alternative to rev query parameter or document key. Optional
func (r ApiDesignDocPutRequest) IfMatch(ifMatch string) ApiDesignDocPutRequest {
	r.ifMatch = &ifMatch
	return r
}

// Document’s revision if updating an existing document. Alternative to If-Match header or document key. Optional
func (r ApiDesignDocPutRequest) Rev(rev string) ApiDesignDocPutRequest {
	r.rev = &rev
	return r
}

// Include conflicts information in response. Ignored if include_docs isn’t true. Default is false.
func (r ApiDesignDocPutRequest) Conflicts(conflicts bool) ApiDesignDocPutRequest {
	r.conflicts = &conflicts
	return r
}

// Return the documents in descending order by key. Default is false.
func (r ApiDesignDocPutRequest) Descending(descending bool) ApiDesignDocPutRequest {
	r.descending = &descending
	return r
}

// Group the results using the reduce function to a group or single row. Implies reduce is true and the maximum group_level. Default is false.
func (r ApiDesignDocPutRequest) Group(group bool) ApiDesignDocPutRequest {
	r.group = &group
	return r
}

// Specify the group level to be used. Implies group is true.
func (r ApiDesignDocPutRequest) GroupLevel(groupLevel int32) ApiDesignDocPutRequest {
	r.groupLevel = &groupLevel
	return r
}

// Include the Base64-encoded content of attachments in the documents that are included if include_docs is true. Ignored if include_docs isn’t true. Default is false.
func (r ApiDesignDocPutRequest) Attachments(attachments bool) ApiDesignDocPutRequest {
	r.attachments = &attachments
	return r
}

// Include encoding information in attachment stubs if include_docs is true and the particular attachment is compressed. Ignored if include_docs isn’t true. Default is false.
func (r ApiDesignDocPutRequest) AttEncodingInfo(attEncodingInfo bool) ApiDesignDocPutRequest {
	r.attEncodingInfo = &attEncodingInfo
	return r
}

// Specifies whether the specified end key should be included in the result. Default is true.
func (r ApiDesignDocPutRequest) InclusiveEnd(inclusiveEnd bool) ApiDesignDocPutRequest {
	r.inclusiveEnd = &inclusiveEnd
	return r
}

// Limit the number of the returned documents to the specified number.
func (r ApiDesignDocPutRequest) Limit(limit int32) ApiDesignDocPutRequest {
	r.limit = &limit
	return r
}

// Use the reduction function. Default is true when a reduce function is defined.
func (r ApiDesignDocPutRequest) Reduce(reduce bool) ApiDesignDocPutRequest {
	r.reduce = &reduce
	return r
}

// Skip this number of records before starting to return the results. Default is 0.
func (r ApiDesignDocPutRequest) Skip(skip int32) ApiDesignDocPutRequest {
	r.skip = &skip
	return r
}

// Sort returned rows (see Sorting Returned Rows). Setting this to false offers a performance boost. The total_rows and offset fields are not available when this is set to false. Default is true.
func (r ApiDesignDocPutRequest) Sorted(sorted bool) ApiDesignDocPutRequest {
	r.sorted = &sorted
	return r
}

// Whether or not the view results should be returned from a stable set of shards. Default is false.
func (r ApiDesignDocPutRequest) Stable(stable bool) ApiDesignDocPutRequest {
	r.stable = &stable
	return r
}

// Allow the results from a stale view to be used. Supported values: ok and update_after. ok is equivalent to stable&#x3D;true&amp;update&#x3D;false. update_after is equivalent to stable&#x3D;true&amp;update&#x3D;lazy. The default behavior is equivalent to stable&#x3D;false&amp;update&#x3D;true. Note that this parameter is deprecated. Use stable and update instead. See Views Generation for more details. 
func (r ApiDesignDocPutRequest) Stale(stale string) ApiDesignDocPutRequest {
	r.stale = &stale
	return r
}

// Return records starting with the specified document ID. Ignored if startkey is not set.
func (r ApiDesignDocPutRequest) StartkeyDocid(startkeyDocid string) ApiDesignDocPutRequest {
	r.startkeyDocid = &startkeyDocid
	return r
}

// Alias for startkey_docid param
func (r ApiDesignDocPutRequest) StartKeyDocId(startKeyDocId string) ApiDesignDocPutRequest {
	r.startKeyDocId = &startKeyDocId
	return r
}

// Whether or not the view in question should be updated prior to responding to the user. Supported values: true, false, lazy. Default is true. 
func (r ApiDesignDocPutRequest) Update(update string) ApiDesignDocPutRequest {
	r.update = &update
	return r
}

// Whether to include in the response an update_seq value indicating the sequence id of the database the view reflects. Default is false.
func (r ApiDesignDocPutRequest) UpdateSeq(updateSeq bool) ApiDesignDocPutRequest {
	r.updateSeq = &updateSeq
	return r
}

func (r ApiDesignDocPutRequest) Execute() (*DocumentOK, *http.Response, error) {
	return r.ApiService.DesignDocPutExecute(r)
}

/*
DesignDocPut The PUT method creates a new named design document, or creates a new revision of the existing design document.

*Note*
that for filters, lists, shows and updates fields objects are mapping of function name to string function source code. For views mapping is the same except that values are objects with map and reduce (optional) keys which also contains functions source code.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param ddoc Design document id
 @return ApiDesignDocPutRequest
*/
func (a *DesignDocumentsApiService) DesignDocPut(ctx context.Context, db string, ddoc string) ApiDesignDocPutRequest {
	return ApiDesignDocPutRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		ddoc: ddoc,
	}
}

// Execute executes the request
//  @return DocumentOK
func (a *DesignDocumentsApiService) DesignDocPutExecute(r ApiDesignDocPutRequest) (*DocumentOK, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DocumentOK
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DesignDocumentsApiService.DesignDocPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_design/{ddoc}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ddoc"+"}", url.PathEscape(parameterValueToString(r.ddoc, "ddoc")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.rev != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rev", r.rev, "")
	}
	if r.conflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicts", r.conflicts, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.groupLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_level", r.groupLevel, "")
	}
	if r.attachments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachments", r.attachments, "")
	}
	if r.attEncodingInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "att_encoding_info", r.attEncodingInfo, "")
	}
	if r.inclusiveEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclusive_end", r.inclusiveEnd, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.reduce != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reduce", r.reduce, "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "")
	}
	if r.sorted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sorted", r.sorted, "")
	}
	if r.stable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stable", r.stable, "")
	}
	if r.stale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stale", r.stale, "")
	}
	if r.startkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey_docid", r.startkeyDocid, "")
	}
	if r.startKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key_doc_id", r.startKeyDocId, "")
	}
	if r.update != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update", r.update, "")
	}
	if r.updateSeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_seq", r.updateSeq, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-Match", r.ifMatch, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDesignDocSearchRequest struct {
	ctx context.Context
	ApiService DesignDocumentsApi
	db string
	ddoc string
	index string
	bookmark *string
	counts *string
	drilldown *string
	groupField *string
	groupSort *string
	highlightFields *string
	highlightPreTag *string
	highlightPostTag *string
	highlightNumber *int32
	highlightSize *int32
	includeDocs *bool
	includeFields *string
	limit *int32
	q *string
	query *string
	range_ *string
	sort *string
	stale *string
}

// A bookmark received from a previous search. This parameter enables paging through the results. If there are no more results after the bookmark, you get a response with an empty rows array and the same bookmark, confirming the end of the result list.
func (r ApiDesignDocSearchRequest) Bookmark(bookmark string) ApiDesignDocSearchRequest {
	r.bookmark = &bookmark
	return r
}

// An array of names of string fields for which counts are requested. The response contains counts for each unique value of this field name among the documents that match the search query. Faceting must be enabled for this parameter to function.
func (r ApiDesignDocSearchRequest) Counts(counts string) ApiDesignDocSearchRequest {
	r.counts = &counts
	return r
}

// This field can be used several times. Each use defines a pair with a field name and a value. The search matches only documents containing the value that was provided in the named field. It differs from using \&quot;fieldname:value\&quot; in the q parameter only in that the values are not analyzed. Faceting must be enabled for this parameter to function.
func (r ApiDesignDocSearchRequest) Drilldown(drilldown string) ApiDesignDocSearchRequest {
	r.drilldown = &drilldown
	return r
}

// Field by which to group search matches. :query number group_limit: Maximum group count. This field can be used only if group_field is specified. 
func (r ApiDesignDocSearchRequest) GroupField(groupField string) ApiDesignDocSearchRequest {
	r.groupField = &groupField
	return r
}

// This field defines the order of the groups in a search that uses group_field. The default sort order is relevance.
func (r ApiDesignDocSearchRequest) GroupSort(groupSort string) ApiDesignDocSearchRequest {
	r.groupSort = &groupSort
	return r
}

// Specifies which fields to highlight. If specified, the result object contains a highlights field with an entry for each specified field.
func (r ApiDesignDocSearchRequest) HighlightFields(highlightFields string) ApiDesignDocSearchRequest {
	r.highlightFields = &highlightFields
	return r
}

// A string that is inserted before the highlighted word in the highlights output.
func (r ApiDesignDocSearchRequest) HighlightPreTag(highlightPreTag string) ApiDesignDocSearchRequest {
	r.highlightPreTag = &highlightPreTag
	return r
}

// A string that is inserted after the highlighted word in the highlights output.
func (r ApiDesignDocSearchRequest) HighlightPostTag(highlightPostTag string) ApiDesignDocSearchRequest {
	r.highlightPostTag = &highlightPostTag
	return r
}

// Number of fragments that are returned in highlights. If the search term occurs less often than the number of fragments that are specified, longer fragments are returned.
func (r ApiDesignDocSearchRequest) HighlightNumber(highlightNumber int32) ApiDesignDocSearchRequest {
	r.highlightNumber = &highlightNumber
	return r
}

// Number of characters in each fragment for highlights.
func (r ApiDesignDocSearchRequest) HighlightSize(highlightSize int32) ApiDesignDocSearchRequest {
	r.highlightSize = &highlightSize
	return r
}

// Include the full content of the documents in the response.
func (r ApiDesignDocSearchRequest) IncludeDocs(includeDocs bool) ApiDesignDocSearchRequest {
	r.includeDocs = &includeDocs
	return r
}

// A JSON array of field names to include in search results. Any fields that are included must be indexed with the store:true option. limit (number) – Limit the number of the returned documents to the specified number. For a grouped search, this parameter limits the number of documents per group. 
func (r ApiDesignDocSearchRequest) IncludeFields(includeFields string) ApiDesignDocSearchRequest {
	r.includeFields = &includeFields
	return r
}

// Limit the number of the returned documents to the specified number. For a grouped search, this parameter limits the number of documents per group.
func (r ApiDesignDocSearchRequest) Limit(limit int32) ApiDesignDocSearchRequest {
	r.limit = &limit
	return r
}

// Alias for query.
func (r ApiDesignDocSearchRequest) Q(q string) ApiDesignDocSearchRequest {
	r.q = &q
	return r
}

// Required. The Lucene query string.
func (r ApiDesignDocSearchRequest) Query(query string) ApiDesignDocSearchRequest {
	r.query = &query
	return r
}

// This field defines ranges for faceted, numeric search fields. The value is a JSON object where the fields names are faceted numeric search fields, and the values of the fields are JSON objects. The field names of the JSON objects are names for ranges. The values are strings that describe the range, for example “[0 TO 10]”.
func (r ApiDesignDocSearchRequest) Range_(range_ string) ApiDesignDocSearchRequest {
	r.range_ = &range_
	return r
}

// Specifies the sort order of the results. In a grouped search (when group_field is used), this parameter specifies the sort order within a group. The default sort order is relevance. A JSON string of the form \&quot;fieldname&lt;type&gt;\&quot; or -fieldname&lt;type&gt; for descending order, where fieldname is the name of a string or number field, and type is either a number, a string, or a JSON array of strings. The type part is optional, and defaults to number. Some examples are \&quot;foo\&quot;, \&quot;-foo\&quot;, \&quot;bar&lt;string&gt;\&quot;, \&quot;-foo&lt;number&gt;\&quot; and [\&quot;-foo&lt;number&gt;\&quot;, \&quot;bar&lt;string&gt;\&quot;]. String fields that are used for sorting must not be analyzed fields. Fields that are used for sorting must be indexed by the same indexer that is used for the search query.
func (r ApiDesignDocSearchRequest) Sort(sort string) ApiDesignDocSearchRequest {
	r.sort = &sort
	return r
}

// Set to ok to allow the use of an out-of-date index.
func (r ApiDesignDocSearchRequest) Stale(stale string) ApiDesignDocSearchRequest {
	r.stale = &stale
	return r
}

func (r ApiDesignDocSearchRequest) Execute() (*Pagination, *http.Response, error) {
	return r.ApiService.DesignDocSearchExecute(r)
}

/*
DesignDocSearch Executes a search request against the named index in the specified design document.

*Warning*
Search endpoints require a running search plugin connected to each cluster node. See Search Plugin Installation for details.

*Note*
You must enable faceting before you can use the counts, drilldown, and ranges parameters.

*Note*
Faceting and grouping are not supported on partitioned searches, so the following query parameters should not be used on those requests: counts, drilldown, ranges, and group_field, group_limit, group_sort``.

*Note*        
Do not combine the bookmark and stale options. These options constrain the choice of shard replicas to use for the response. When used together, the options might cause problems when contact is attempted with replicas that are slow or not available.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param ddoc Design document id
 @param index Search index name
 @return ApiDesignDocSearchRequest
*/
func (a *DesignDocumentsApiService) DesignDocSearch(ctx context.Context, db string, ddoc string, index string) ApiDesignDocSearchRequest {
	return ApiDesignDocSearchRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		ddoc: ddoc,
		index: index,
	}
}

// Execute executes the request
//  @return Pagination
func (a *DesignDocumentsApiService) DesignDocSearchExecute(r ApiDesignDocSearchRequest) (*Pagination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Pagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DesignDocumentsApiService.DesignDocSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_design/{ddoc}/_search/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ddoc"+"}", url.PathEscape(parameterValueToString(r.ddoc, "ddoc")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bookmark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookmark", r.bookmark, "")
	}
	if r.counts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "counts", r.counts, "")
	}
	if r.drilldown != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "drilldown", r.drilldown, "")
	}
	if r.groupField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_field", r.groupField, "")
	}
	if r.groupSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_sort", r.groupSort, "")
	}
	if r.highlightFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "highlight_fields", r.highlightFields, "")
	}
	if r.highlightPreTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "highlight_pre_tag", r.highlightPreTag, "")
	}
	if r.highlightPostTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "highlight_post_tag", r.highlightPostTag, "")
	}
	if r.highlightNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "highlight_number", r.highlightNumber, "")
	}
	if r.highlightSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "highlight_size", r.highlightSize, "")
	}
	if r.includeDocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_docs", r.includeDocs, "")
	}
	if r.includeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_fields", r.includeFields, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "range", r.range_, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.stale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stale", r.stale, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDesignDocSearchInfoRequest struct {
	ctx context.Context
	ApiService DesignDocumentsApi
	db string
	ddoc string
	index string
}

func (r ApiDesignDocSearchInfoRequest) Execute() (*InlineResponse2008, *http.Response, error) {
	return r.ApiService.DesignDocSearchInfoExecute(r)
}

/*
DesignDocSearchInfo Executes a search request against the named index in the specified design document.

*Warning*
Search endpoints require a running search plugin connected to each cluster node. See Search Plugin Installation for details.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param ddoc Design document id
 @param index Search index name
 @return ApiDesignDocSearchInfoRequest
*/
func (a *DesignDocumentsApiService) DesignDocSearchInfo(ctx context.Context, db string, ddoc string, index string) ApiDesignDocSearchInfoRequest {
	return ApiDesignDocSearchInfoRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		ddoc: ddoc,
		index: index,
	}
}

// Execute executes the request
//  @return InlineResponse2008
func (a *DesignDocumentsApiService) DesignDocSearchInfoExecute(r ApiDesignDocSearchInfoRequest) (*InlineResponse2008, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineResponse2008
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DesignDocumentsApiService.DesignDocSearchInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_design/{ddoc}/_search_info/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ddoc"+"}", url.PathEscape(parameterValueToString(r.ddoc, "ddoc")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDesignDocViewRequest struct {
	ctx context.Context
	ApiService DesignDocumentsApi
	db string
	ddoc string
	view string
	conflicts *bool
	descending *bool
	endkey *string
	endKey *string
	endkeyDocid *string
	endKeyDocId *string
	group *bool
	groupLevel *int32
	includeDocs *bool
	attachments *bool
	attEncodingInfo *bool
	inclusiveEnd *bool
	revsInfo *bool
	key *string
	keys *[]string
	limit *int32
	reduce *bool
	skip *int32
	sorted *bool
	stable *bool
	stale *string
	startkey *string
	startKey *string
	startkeyDocid *string
	startKeyDocId *string
	update *string
	updateSeq *bool
}

// Include conflicts information in response. Ignored if include_docs isn’t true. Default is false.
func (r ApiDesignDocViewRequest) Conflicts(conflicts bool) ApiDesignDocViewRequest {
	r.conflicts = &conflicts
	return r
}

// Return the documents in descending order by key. Default is false.
func (r ApiDesignDocViewRequest) Descending(descending bool) ApiDesignDocViewRequest {
	r.descending = &descending
	return r
}

// Stop returning records when the specified key is reached.
func (r ApiDesignDocViewRequest) Endkey(endkey string) ApiDesignDocViewRequest {
	r.endkey = &endkey
	return r
}

// Alias for endkey param
func (r ApiDesignDocViewRequest) EndKey(endKey string) ApiDesignDocViewRequest {
	r.endKey = &endKey
	return r
}

// Stop returning records when the specified document ID is reached. Ignored if endkey is not set.
func (r ApiDesignDocViewRequest) EndkeyDocid(endkeyDocid string) ApiDesignDocViewRequest {
	r.endkeyDocid = &endkeyDocid
	return r
}

// Alias for endkey_docid.
func (r ApiDesignDocViewRequest) EndKeyDocId(endKeyDocId string) ApiDesignDocViewRequest {
	r.endKeyDocId = &endKeyDocId
	return r
}

// Group the results using the reduce function to a group or single row. Implies reduce is true and the maximum group_level. Default is false.
func (r ApiDesignDocViewRequest) Group(group bool) ApiDesignDocViewRequest {
	r.group = &group
	return r
}

// Specify the group level to be used. Implies group is true.
func (r ApiDesignDocViewRequest) GroupLevel(groupLevel int32) ApiDesignDocViewRequest {
	r.groupLevel = &groupLevel
	return r
}

// Include the associated document with each row. Default is false.
func (r ApiDesignDocViewRequest) IncludeDocs(includeDocs bool) ApiDesignDocViewRequest {
	r.includeDocs = &includeDocs
	return r
}

// Include the Base64-encoded content of attachments in the documents that are included if include_docs is true. Ignored if include_docs isn’t true. Default is false.
func (r ApiDesignDocViewRequest) Attachments(attachments bool) ApiDesignDocViewRequest {
	r.attachments = &attachments
	return r
}

// Include encoding information in attachment stubs if include_docs is true and the particular attachment is compressed. Ignored if include_docs isn’t true. Default is false.
func (r ApiDesignDocViewRequest) AttEncodingInfo(attEncodingInfo bool) ApiDesignDocViewRequest {
	r.attEncodingInfo = &attEncodingInfo
	return r
}

// Specifies whether the specified end key should be included in the result. Default is true.
func (r ApiDesignDocViewRequest) InclusiveEnd(inclusiveEnd bool) ApiDesignDocViewRequest {
	r.inclusiveEnd = &inclusiveEnd
	return r
}

// Includes detailed information for all known document revisions. Default is false
func (r ApiDesignDocViewRequest) RevsInfo(revsInfo bool) ApiDesignDocViewRequest {
	r.revsInfo = &revsInfo
	return r
}

// eturn only documents that match the specified key.
func (r ApiDesignDocViewRequest) Key(key string) ApiDesignDocViewRequest {
	r.key = &key
	return r
}

// Return only documents where the key matches one of the keys specified in the array.
func (r ApiDesignDocViewRequest) Keys(keys []string) ApiDesignDocViewRequest {
	r.keys = &keys
	return r
}

// Limit the number of the returned documents to the specified number.
func (r ApiDesignDocViewRequest) Limit(limit int32) ApiDesignDocViewRequest {
	r.limit = &limit
	return r
}

// Use the reduction function. Default is true when a reduce function is defined.
func (r ApiDesignDocViewRequest) Reduce(reduce bool) ApiDesignDocViewRequest {
	r.reduce = &reduce
	return r
}

// Skip this number of records before starting to return the results. Default is 0.
func (r ApiDesignDocViewRequest) Skip(skip int32) ApiDesignDocViewRequest {
	r.skip = &skip
	return r
}

// Sort returned rows (see Sorting Returned Rows). Setting this to false offers a performance boost. The total_rows and offset fields are not available when this is set to false. Default is true.
func (r ApiDesignDocViewRequest) Sorted(sorted bool) ApiDesignDocViewRequest {
	r.sorted = &sorted
	return r
}

// Whether or not the view results should be returned from a stable set of shards. Default is false.
func (r ApiDesignDocViewRequest) Stable(stable bool) ApiDesignDocViewRequest {
	r.stable = &stable
	return r
}

// Allow the results from a stale view to be used. Supported values: ok and update_after. ok is equivalent to stable&#x3D;true&amp;update&#x3D;false. update_after is equivalent to stable&#x3D;true&amp;update&#x3D;lazy. The default behavior is equivalent to stable&#x3D;false&amp;update&#x3D;true. Note that this parameter is deprecated. Use stable and update instead. See Views Generation for more details. 
func (r ApiDesignDocViewRequest) Stale(stale string) ApiDesignDocViewRequest {
	r.stale = &stale
	return r
}

// Return records starting with the specified key.
func (r ApiDesignDocViewRequest) Startkey(startkey string) ApiDesignDocViewRequest {
	r.startkey = &startkey
	return r
}

// Alias for startkey.
func (r ApiDesignDocViewRequest) StartKey(startKey string) ApiDesignDocViewRequest {
	r.startKey = &startKey
	return r
}

// Return records starting with the specified document ID. Ignored if startkey is not set.
func (r ApiDesignDocViewRequest) StartkeyDocid(startkeyDocid string) ApiDesignDocViewRequest {
	r.startkeyDocid = &startkeyDocid
	return r
}

// Alias for startkey_docid param
func (r ApiDesignDocViewRequest) StartKeyDocId(startKeyDocId string) ApiDesignDocViewRequest {
	r.startKeyDocId = &startKeyDocId
	return r
}

// Whether or not the view in question should be updated prior to responding to the user. Supported values: true, false, lazy. Default is true. 
func (r ApiDesignDocViewRequest) Update(update string) ApiDesignDocViewRequest {
	r.update = &update
	return r
}

// Whether to include in the response an update_seq value indicating the sequence id of the database the view reflects. Default is false.
func (r ApiDesignDocViewRequest) UpdateSeq(updateSeq bool) ApiDesignDocViewRequest {
	r.updateSeq = &updateSeq
	return r
}

func (r ApiDesignDocViewRequest) Execute() (*Pagination, *http.Response, error) {
	return r.ApiService.DesignDocViewExecute(r)
}

/*
DesignDocView Executes the specified view function from the specified design document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param ddoc Design document id
 @param view View function name
 @return ApiDesignDocViewRequest
*/
func (a *DesignDocumentsApiService) DesignDocView(ctx context.Context, db string, ddoc string, view string) ApiDesignDocViewRequest {
	return ApiDesignDocViewRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		ddoc: ddoc,
		view: view,
	}
}

// Execute executes the request
//  @return Pagination
func (a *DesignDocumentsApiService) DesignDocViewExecute(r ApiDesignDocViewRequest) (*Pagination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Pagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DesignDocumentsApiService.DesignDocView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_design/{ddoc}/_view/{view}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ddoc"+"}", url.PathEscape(parameterValueToString(r.ddoc, "ddoc")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"view"+"}", url.PathEscape(parameterValueToString(r.view, "view")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.conflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicts", r.conflicts, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.endkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endkey", r.endkey, "")
	}
	if r.endKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_key", r.endKey, "")
	}
	if r.endkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endkey_docid", r.endkeyDocid, "")
	}
	if r.endKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_key_doc_id", r.endKeyDocId, "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.groupLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_level", r.groupLevel, "")
	}
	if r.includeDocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_docs", r.includeDocs, "")
	}
	if r.attachments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachments", r.attachments, "")
	}
	if r.attEncodingInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "att_encoding_info", r.attEncodingInfo, "")
	}
	if r.inclusiveEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclusive_end", r.inclusiveEnd, "")
	}
	if r.revsInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revs_info", r.revsInfo, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.keys != nil {
		t := *r.keys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "keys", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "keys", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.reduce != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reduce", r.reduce, "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "")
	}
	if r.sorted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sorted", r.sorted, "")
	}
	if r.stable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stable", r.stable, "")
	}
	if r.stale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stale", r.stale, "")
	}
	if r.startkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey", r.startkey, "")
	}
	if r.startKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key", r.startKey, "")
	}
	if r.startkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey_docid", r.startkeyDocid, "")
	}
	if r.startKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key_doc_id", r.startKeyDocId, "")
	}
	if r.update != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update", r.update, "")
	}
	if r.updateSeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_seq", r.updateSeq, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDesignDocViewPostRequest struct {
	ctx context.Context
	ApiService DesignDocumentsApi
	db string
	ddoc string
	view string
	body *Keys
	conflicts *bool
	descending *bool
	endkey *string
	endKey *string
	endkeyDocid *string
	endKeyDocId *string
	group *bool
	groupLevel *int32
	includeDocs *bool
	attachments *bool
	attEncodingInfo *bool
	inclusiveEnd *bool
	revsInfo *bool
	key *string
	keys *[]string
	limit *int32
	reduce *bool
	skip *int32
	sorted *bool
	stable *bool
	stale *string
	startkey *string
	startKey *string
	startkeyDocid *string
	startKeyDocId *string
	update *string
	updateSeq *bool
}

func (r ApiDesignDocViewPostRequest) Body(body Keys) ApiDesignDocViewPostRequest {
	r.body = &body
	return r
}

// Include conflicts information in response. Ignored if include_docs isn’t true. Default is false.
func (r ApiDesignDocViewPostRequest) Conflicts(conflicts bool) ApiDesignDocViewPostRequest {
	r.conflicts = &conflicts
	return r
}

// Return the documents in descending order by key. Default is false.
func (r ApiDesignDocViewPostRequest) Descending(descending bool) ApiDesignDocViewPostRequest {
	r.descending = &descending
	return r
}

// Stop returning records when the specified key is reached.
func (r ApiDesignDocViewPostRequest) Endkey(endkey string) ApiDesignDocViewPostRequest {
	r.endkey = &endkey
	return r
}

// Alias for endkey param
func (r ApiDesignDocViewPostRequest) EndKey(endKey string) ApiDesignDocViewPostRequest {
	r.endKey = &endKey
	return r
}

// Stop returning records when the specified document ID is reached. Ignored if endkey is not set.
func (r ApiDesignDocViewPostRequest) EndkeyDocid(endkeyDocid string) ApiDesignDocViewPostRequest {
	r.endkeyDocid = &endkeyDocid
	return r
}

// Alias for endkey_docid.
func (r ApiDesignDocViewPostRequest) EndKeyDocId(endKeyDocId string) ApiDesignDocViewPostRequest {
	r.endKeyDocId = &endKeyDocId
	return r
}

// Group the results using the reduce function to a group or single row. Implies reduce is true and the maximum group_level. Default is false.
func (r ApiDesignDocViewPostRequest) Group(group bool) ApiDesignDocViewPostRequest {
	r.group = &group
	return r
}

// Specify the group level to be used. Implies group is true.
func (r ApiDesignDocViewPostRequest) GroupLevel(groupLevel int32) ApiDesignDocViewPostRequest {
	r.groupLevel = &groupLevel
	return r
}

// Include the associated document with each row. Default is false.
func (r ApiDesignDocViewPostRequest) IncludeDocs(includeDocs bool) ApiDesignDocViewPostRequest {
	r.includeDocs = &includeDocs
	return r
}

// Include the Base64-encoded content of attachments in the documents that are included if include_docs is true. Ignored if include_docs isn’t true. Default is false.
func (r ApiDesignDocViewPostRequest) Attachments(attachments bool) ApiDesignDocViewPostRequest {
	r.attachments = &attachments
	return r
}

// Include encoding information in attachment stubs if include_docs is true and the particular attachment is compressed. Ignored if include_docs isn’t true. Default is false.
func (r ApiDesignDocViewPostRequest) AttEncodingInfo(attEncodingInfo bool) ApiDesignDocViewPostRequest {
	r.attEncodingInfo = &attEncodingInfo
	return r
}

// Specifies whether the specified end key should be included in the result. Default is true.
func (r ApiDesignDocViewPostRequest) InclusiveEnd(inclusiveEnd bool) ApiDesignDocViewPostRequest {
	r.inclusiveEnd = &inclusiveEnd
	return r
}

// Includes detailed information for all known document revisions. Default is false
func (r ApiDesignDocViewPostRequest) RevsInfo(revsInfo bool) ApiDesignDocViewPostRequest {
	r.revsInfo = &revsInfo
	return r
}

// eturn only documents that match the specified key.
func (r ApiDesignDocViewPostRequest) Key(key string) ApiDesignDocViewPostRequest {
	r.key = &key
	return r
}

// Return only documents where the key matches one of the keys specified in the array.
func (r ApiDesignDocViewPostRequest) Keys(keys []string) ApiDesignDocViewPostRequest {
	r.keys = &keys
	return r
}

// Limit the number of the returned documents to the specified number.
func (r ApiDesignDocViewPostRequest) Limit(limit int32) ApiDesignDocViewPostRequest {
	r.limit = &limit
	return r
}

// Use the reduction function. Default is true when a reduce function is defined.
func (r ApiDesignDocViewPostRequest) Reduce(reduce bool) ApiDesignDocViewPostRequest {
	r.reduce = &reduce
	return r
}

// Skip this number of records before starting to return the results. Default is 0.
func (r ApiDesignDocViewPostRequest) Skip(skip int32) ApiDesignDocViewPostRequest {
	r.skip = &skip
	return r
}

// Sort returned rows (see Sorting Returned Rows). Setting this to false offers a performance boost. The total_rows and offset fields are not available when this is set to false. Default is true.
func (r ApiDesignDocViewPostRequest) Sorted(sorted bool) ApiDesignDocViewPostRequest {
	r.sorted = &sorted
	return r
}

// Whether or not the view results should be returned from a stable set of shards. Default is false.
func (r ApiDesignDocViewPostRequest) Stable(stable bool) ApiDesignDocViewPostRequest {
	r.stable = &stable
	return r
}

// Allow the results from a stale view to be used. Supported values: ok and update_after. ok is equivalent to stable&#x3D;true&amp;update&#x3D;false. update_after is equivalent to stable&#x3D;true&amp;update&#x3D;lazy. The default behavior is equivalent to stable&#x3D;false&amp;update&#x3D;true. Note that this parameter is deprecated. Use stable and update instead. See Views Generation for more details. 
func (r ApiDesignDocViewPostRequest) Stale(stale string) ApiDesignDocViewPostRequest {
	r.stale = &stale
	return r
}

// Return records starting with the specified key.
func (r ApiDesignDocViewPostRequest) Startkey(startkey string) ApiDesignDocViewPostRequest {
	r.startkey = &startkey
	return r
}

// Alias for startkey.
func (r ApiDesignDocViewPostRequest) StartKey(startKey string) ApiDesignDocViewPostRequest {
	r.startKey = &startKey
	return r
}

// Return records starting with the specified document ID. Ignored if startkey is not set.
func (r ApiDesignDocViewPostRequest) StartkeyDocid(startkeyDocid string) ApiDesignDocViewPostRequest {
	r.startkeyDocid = &startkeyDocid
	return r
}

// Alias for startkey_docid param
func (r ApiDesignDocViewPostRequest) StartKeyDocId(startKeyDocId string) ApiDesignDocViewPostRequest {
	r.startKeyDocId = &startKeyDocId
	return r
}

// Whether or not the view in question should be updated prior to responding to the user. Supported values: true, false, lazy. Default is true. 
func (r ApiDesignDocViewPostRequest) Update(update string) ApiDesignDocViewPostRequest {
	r.update = &update
	return r
}

// Whether to include in the response an update_seq value indicating the sequence id of the database the view reflects. Default is false.
func (r ApiDesignDocViewPostRequest) UpdateSeq(updateSeq bool) ApiDesignDocViewPostRequest {
	r.updateSeq = &updateSeq
	return r
}

func (r ApiDesignDocViewPostRequest) Execute() (*Pagination, *http.Response, error) {
	return r.ApiService.DesignDocViewPostExecute(r)
}

/*
DesignDocViewPost Executes the specified view function from the specified design document.

POST view functionality supports identical parameters and behavior as specified in the GET /{db}/_design/{ddoc}/_view/{view} API but allows for the query string parameters to be supplied as keys in a JSON object in the body of the POST request.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param ddoc Design document id
 @param view View function name
 @return ApiDesignDocViewPostRequest
*/
func (a *DesignDocumentsApiService) DesignDocViewPost(ctx context.Context, db string, ddoc string, view string) ApiDesignDocViewPostRequest {
	return ApiDesignDocViewPostRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		ddoc: ddoc,
		view: view,
	}
}

// Execute executes the request
//  @return Pagination
func (a *DesignDocumentsApiService) DesignDocViewPostExecute(r ApiDesignDocViewPostRequest) (*Pagination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Pagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DesignDocumentsApiService.DesignDocViewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_design/{ddoc}/_view/{view}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ddoc"+"}", url.PathEscape(parameterValueToString(r.ddoc, "ddoc")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"view"+"}", url.PathEscape(parameterValueToString(r.view, "view")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.conflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicts", r.conflicts, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.endkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endkey", r.endkey, "")
	}
	if r.endKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_key", r.endKey, "")
	}
	if r.endkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endkey_docid", r.endkeyDocid, "")
	}
	if r.endKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_key_doc_id", r.endKeyDocId, "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.groupLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_level", r.groupLevel, "")
	}
	if r.includeDocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_docs", r.includeDocs, "")
	}
	if r.attachments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachments", r.attachments, "")
	}
	if r.attEncodingInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "att_encoding_info", r.attEncodingInfo, "")
	}
	if r.inclusiveEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclusive_end", r.inclusiveEnd, "")
	}
	if r.revsInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revs_info", r.revsInfo, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.keys != nil {
		t := *r.keys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "keys", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "keys", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.reduce != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reduce", r.reduce, "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "")
	}
	if r.sorted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sorted", r.sorted, "")
	}
	if r.stable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stable", r.stable, "")
	}
	if r.stale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stale", r.stale, "")
	}
	if r.startkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey", r.startkey, "")
	}
	if r.startKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key", r.startKey, "")
	}
	if r.startkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey_docid", r.startkeyDocid, "")
	}
	if r.startKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key_doc_id", r.startKeyDocId, "")
	}
	if r.update != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update", r.update, "")
	}
	if r.updateSeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_seq", r.updateSeq, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
