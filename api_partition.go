/*
CouchDB API

*Note* This is not a definitive implementation of the CouchDB API, it's missing a lot of the endpoints for server/database managment and everything for attachments all COPY operations and probably a few other parts.  It also targets golang, as such the '#/definitions/Document' is intentionally left empty to generate a go `interface`, which you can then cast to a `map[string]interface{}`. 

API version: 4.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package couchdb_go

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PartitionApiService PartitionApi service
type PartitionApiService service

type ApiPartitionDesignDocSearchRequest struct {
	ctx context.Context
	ApiService *PartitionApiService
	db string
	partition string
	ddoc string
	index string
	bookmark *string
	counts *string
	drilldown *string
	groupField *string
	groupSort *string
	highlightFields *string
	highlightPreTag *string
	highlightPostTag *string
	highlightNumber *int32
	highlightSize *int32
	includeDocs *bool
	includeFields *string
	limit *int32
	q *string
	query *string
	range_ *string
	sort *string
	stale *string
}

// A bookmark received from a previous search. This parameter enables paging through the results. If there are no more results after the bookmark, you get a response with an empty rows array and the same bookmark, confirming the end of the result list.
func (r ApiPartitionDesignDocSearchRequest) Bookmark(bookmark string) ApiPartitionDesignDocSearchRequest {
	r.bookmark = &bookmark
	return r
}

// An array of names of string fields for which counts are requested. The response contains counts for each unique value of this field name among the documents that match the search query. Faceting must be enabled for this parameter to function.
func (r ApiPartitionDesignDocSearchRequest) Counts(counts string) ApiPartitionDesignDocSearchRequest {
	r.counts = &counts
	return r
}

// This field can be used several times. Each use defines a pair with a field name and a value. The search matches only documents containing the value that was provided in the named field. It differs from using \&quot;fieldname:value\&quot; in the q parameter only in that the values are not analyzed. Faceting must be enabled for this parameter to function.
func (r ApiPartitionDesignDocSearchRequest) Drilldown(drilldown string) ApiPartitionDesignDocSearchRequest {
	r.drilldown = &drilldown
	return r
}

// Field by which to group search matches. :query number group_limit: Maximum group count. This field can be used only if group_field is specified. 
func (r ApiPartitionDesignDocSearchRequest) GroupField(groupField string) ApiPartitionDesignDocSearchRequest {
	r.groupField = &groupField
	return r
}

// This field defines the order of the groups in a search that uses group_field. The default sort order is relevance.
func (r ApiPartitionDesignDocSearchRequest) GroupSort(groupSort string) ApiPartitionDesignDocSearchRequest {
	r.groupSort = &groupSort
	return r
}

// Specifies which fields to highlight. If specified, the result object contains a highlights field with an entry for each specified field.
func (r ApiPartitionDesignDocSearchRequest) HighlightFields(highlightFields string) ApiPartitionDesignDocSearchRequest {
	r.highlightFields = &highlightFields
	return r
}

// A string that is inserted before the highlighted word in the highlights output.
func (r ApiPartitionDesignDocSearchRequest) HighlightPreTag(highlightPreTag string) ApiPartitionDesignDocSearchRequest {
	r.highlightPreTag = &highlightPreTag
	return r
}

// A string that is inserted after the highlighted word in the highlights output.
func (r ApiPartitionDesignDocSearchRequest) HighlightPostTag(highlightPostTag string) ApiPartitionDesignDocSearchRequest {
	r.highlightPostTag = &highlightPostTag
	return r
}

// Number of fragments that are returned in highlights. If the search term occurs less often than the number of fragments that are specified, longer fragments are returned.
func (r ApiPartitionDesignDocSearchRequest) HighlightNumber(highlightNumber int32) ApiPartitionDesignDocSearchRequest {
	r.highlightNumber = &highlightNumber
	return r
}

// Number of characters in each fragment for highlights.
func (r ApiPartitionDesignDocSearchRequest) HighlightSize(highlightSize int32) ApiPartitionDesignDocSearchRequest {
	r.highlightSize = &highlightSize
	return r
}

// Include the full content of the documents in the response.
func (r ApiPartitionDesignDocSearchRequest) IncludeDocs(includeDocs bool) ApiPartitionDesignDocSearchRequest {
	r.includeDocs = &includeDocs
	return r
}

// A JSON array of field names to include in search results. Any fields that are included must be indexed with the store:true option. limit (number) – Limit the number of the returned documents to the specified number. For a grouped search, this parameter limits the number of documents per group. 
func (r ApiPartitionDesignDocSearchRequest) IncludeFields(includeFields string) ApiPartitionDesignDocSearchRequest {
	r.includeFields = &includeFields
	return r
}

// Limit the number of the returned documents to the specified number. For a grouped search, this parameter limits the number of documents per group.
func (r ApiPartitionDesignDocSearchRequest) Limit(limit int32) ApiPartitionDesignDocSearchRequest {
	r.limit = &limit
	return r
}

// Alias for query.
func (r ApiPartitionDesignDocSearchRequest) Q(q string) ApiPartitionDesignDocSearchRequest {
	r.q = &q
	return r
}

// Required. The Lucene query string.
func (r ApiPartitionDesignDocSearchRequest) Query(query string) ApiPartitionDesignDocSearchRequest {
	r.query = &query
	return r
}

// This field defines ranges for faceted, numeric search fields. The value is a JSON object where the fields names are faceted numeric search fields, and the values of the fields are JSON objects. The field names of the JSON objects are names for ranges. The values are strings that describe the range, for example “[0 TO 10]”.
func (r ApiPartitionDesignDocSearchRequest) Range_(range_ string) ApiPartitionDesignDocSearchRequest {
	r.range_ = &range_
	return r
}

// Specifies the sort order of the results. In a grouped search (when group_field is used), this parameter specifies the sort order within a group. The default sort order is relevance. A JSON string of the form \&quot;fieldname&lt;type&gt;\&quot; or -fieldname&lt;type&gt; for descending order, where fieldname is the name of a string or number field, and type is either a number, a string, or a JSON array of strings. The type part is optional, and defaults to number. Some examples are \&quot;foo\&quot;, \&quot;-foo\&quot;, \&quot;bar&lt;string&gt;\&quot;, \&quot;-foo&lt;number&gt;\&quot; and [\&quot;-foo&lt;number&gt;\&quot;, \&quot;bar&lt;string&gt;\&quot;]. String fields that are used for sorting must not be analyzed fields. Fields that are used for sorting must be indexed by the same indexer that is used for the search query.
func (r ApiPartitionDesignDocSearchRequest) Sort(sort string) ApiPartitionDesignDocSearchRequest {
	r.sort = &sort
	return r
}

// Set to ok to allow the use of an out-of-date index.
func (r ApiPartitionDesignDocSearchRequest) Stale(stale string) ApiPartitionDesignDocSearchRequest {
	r.stale = &stale
	return r
}

func (r ApiPartitionDesignDocSearchRequest) Execute() (*Pagination, *http.Response, error) {
	return r.ApiService.PartitionDesignDocSearchExecute(r)
}

/*
PartitionDesignDocSearch Executes a search request against the named index in the specified design document.

*Warning*
Search endpoints require a running search plugin connected to each cluster node. See Search Plugin Installation for details.

*Note*
You must enable faceting before you can use the counts, drilldown, and ranges parameters.

*Note*
Faceting and grouping are not supported on partitioned searches, so the following query parameters should not be used on those requests: counts, drilldown, ranges, and group_field, group_limit, group_sort``.

*Note*        
Do not combine the bookmark and stale options. These options constrain the choice of shard replicas to use for the response. When used together, the options might cause problems when contact is attempted with replicas that are slow or not available.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param partition Partition name
 @param ddoc Design document id
 @param index Search index name
 @return ApiPartitionDesignDocSearchRequest
*/
func (a *PartitionApiService) PartitionDesignDocSearch(ctx context.Context, db string, partition string, ddoc string, index string) ApiPartitionDesignDocSearchRequest {
	return ApiPartitionDesignDocSearchRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		partition: partition,
		ddoc: ddoc,
		index: index,
	}
}

// Execute executes the request
//  @return Pagination
func (a *PartitionApiService) PartitionDesignDocSearchExecute(r ApiPartitionDesignDocSearchRequest) (*Pagination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Pagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartitionApiService.PartitionDesignDocSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_partition/{partition}/_design/{ddoc}/_search/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partition"+"}", url.PathEscape(parameterValueToString(r.partition, "partition")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ddoc"+"}", url.PathEscape(parameterValueToString(r.ddoc, "ddoc")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bookmark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookmark", r.bookmark, "")
	}
	if r.counts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "counts", r.counts, "")
	}
	if r.drilldown != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "drilldown", r.drilldown, "")
	}
	if r.groupField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_field", r.groupField, "")
	}
	if r.groupSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_sort", r.groupSort, "")
	}
	if r.highlightFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "highlight_fields", r.highlightFields, "")
	}
	if r.highlightPreTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "highlight_pre_tag", r.highlightPreTag, "")
	}
	if r.highlightPostTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "highlight_post_tag", r.highlightPostTag, "")
	}
	if r.highlightNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "highlight_number", r.highlightNumber, "")
	}
	if r.highlightSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "highlight_size", r.highlightSize, "")
	}
	if r.includeDocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_docs", r.includeDocs, "")
	}
	if r.includeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_fields", r.includeFields, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "range", r.range_, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.stale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stale", r.stale, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPartitionDesignDocViewRequest struct {
	ctx context.Context
	ApiService *PartitionApiService
	db string
	partition string
	ddoc string
	view string
	conflicts *bool
	descending *bool
	endkey *string
	endKey *string
	endkeyDocid *string
	endKeyDocId *string
	group *bool
	groupLevel *int32
	includeDocs *bool
	attachments *bool
	attEncodingInfo *bool
	inclusiveEnd *bool
	revsInfo *bool
	key *string
	keys *string
	limit *int32
	reduce *bool
	skip *int32
	sorted *bool
	stable *bool
	stale *string
	startkey *string
	startKey *string
	startkeyDocid *string
	startKeyDocId *string
	update *string
	updateSeq *bool
}

// Include conflicts information in response. Ignored if include_docs isn’t true. Default is false.
func (r ApiPartitionDesignDocViewRequest) Conflicts(conflicts bool) ApiPartitionDesignDocViewRequest {
	r.conflicts = &conflicts
	return r
}

// Return the documents in descending order by key. Default is false.
func (r ApiPartitionDesignDocViewRequest) Descending(descending bool) ApiPartitionDesignDocViewRequest {
	r.descending = &descending
	return r
}

// Stop returning records when the specified key is reached.
func (r ApiPartitionDesignDocViewRequest) Endkey(endkey string) ApiPartitionDesignDocViewRequest {
	r.endkey = &endkey
	return r
}

// Alias for endkey param
func (r ApiPartitionDesignDocViewRequest) EndKey(endKey string) ApiPartitionDesignDocViewRequest {
	r.endKey = &endKey
	return r
}

// Stop returning records when the specified document ID is reached. Ignored if endkey is not set.
func (r ApiPartitionDesignDocViewRequest) EndkeyDocid(endkeyDocid string) ApiPartitionDesignDocViewRequest {
	r.endkeyDocid = &endkeyDocid
	return r
}

// Alias for endkey_docid.
func (r ApiPartitionDesignDocViewRequest) EndKeyDocId(endKeyDocId string) ApiPartitionDesignDocViewRequest {
	r.endKeyDocId = &endKeyDocId
	return r
}

// Group the results using the reduce function to a group or single row. Implies reduce is true and the maximum group_level. Default is false.
func (r ApiPartitionDesignDocViewRequest) Group(group bool) ApiPartitionDesignDocViewRequest {
	r.group = &group
	return r
}

// Specify the group level to be used. Implies group is true.
func (r ApiPartitionDesignDocViewRequest) GroupLevel(groupLevel int32) ApiPartitionDesignDocViewRequest {
	r.groupLevel = &groupLevel
	return r
}

// Include the associated document with each row. Default is false.
func (r ApiPartitionDesignDocViewRequest) IncludeDocs(includeDocs bool) ApiPartitionDesignDocViewRequest {
	r.includeDocs = &includeDocs
	return r
}

// Include the Base64-encoded content of attachments in the documents that are included if include_docs is true. Ignored if include_docs isn’t true. Default is false.
func (r ApiPartitionDesignDocViewRequest) Attachments(attachments bool) ApiPartitionDesignDocViewRequest {
	r.attachments = &attachments
	return r
}

// Include encoding information in attachment stubs if include_docs is true and the particular attachment is compressed. Ignored if include_docs isn’t true. Default is false.
func (r ApiPartitionDesignDocViewRequest) AttEncodingInfo(attEncodingInfo bool) ApiPartitionDesignDocViewRequest {
	r.attEncodingInfo = &attEncodingInfo
	return r
}

// Specifies whether the specified end key should be included in the result. Default is true.
func (r ApiPartitionDesignDocViewRequest) InclusiveEnd(inclusiveEnd bool) ApiPartitionDesignDocViewRequest {
	r.inclusiveEnd = &inclusiveEnd
	return r
}

// Includes detailed information for all known document revisions. Default is false
func (r ApiPartitionDesignDocViewRequest) RevsInfo(revsInfo bool) ApiPartitionDesignDocViewRequest {
	r.revsInfo = &revsInfo
	return r
}

// eturn only documents that match the specified key.
func (r ApiPartitionDesignDocViewRequest) Key(key string) ApiPartitionDesignDocViewRequest {
	r.key = &key
	return r
}

// Return only documents where the key matches one of the keys specified in the array.
func (r ApiPartitionDesignDocViewRequest) Keys(keys string) ApiPartitionDesignDocViewRequest {
	r.keys = &keys
	return r
}

// Limit the number of the returned documents to the specified number.
func (r ApiPartitionDesignDocViewRequest) Limit(limit int32) ApiPartitionDesignDocViewRequest {
	r.limit = &limit
	return r
}

// Use the reduction function. Default is true when a reduce function is defined.
func (r ApiPartitionDesignDocViewRequest) Reduce(reduce bool) ApiPartitionDesignDocViewRequest {
	r.reduce = &reduce
	return r
}

// Skip this number of records before starting to return the results. Default is 0.
func (r ApiPartitionDesignDocViewRequest) Skip(skip int32) ApiPartitionDesignDocViewRequest {
	r.skip = &skip
	return r
}

// Sort returned rows (see Sorting Returned Rows). Setting this to false offers a performance boost. The total_rows and offset fields are not available when this is set to false. Default is true.
func (r ApiPartitionDesignDocViewRequest) Sorted(sorted bool) ApiPartitionDesignDocViewRequest {
	r.sorted = &sorted
	return r
}

// Whether or not the view results should be returned from a stable set of shards. Default is false.
func (r ApiPartitionDesignDocViewRequest) Stable(stable bool) ApiPartitionDesignDocViewRequest {
	r.stable = &stable
	return r
}

// Allow the results from a stale view to be used. Supported values: ok and update_after. ok is equivalent to stable&#x3D;true&amp;update&#x3D;false. update_after is equivalent to stable&#x3D;true&amp;update&#x3D;lazy. The default behavior is equivalent to stable&#x3D;false&amp;update&#x3D;true. Note that this parameter is deprecated. Use stable and update instead. See Views Generation for more details. 
func (r ApiPartitionDesignDocViewRequest) Stale(stale string) ApiPartitionDesignDocViewRequest {
	r.stale = &stale
	return r
}

// Return records starting with the specified key.
func (r ApiPartitionDesignDocViewRequest) Startkey(startkey string) ApiPartitionDesignDocViewRequest {
	r.startkey = &startkey
	return r
}

// Alias for startkey.
func (r ApiPartitionDesignDocViewRequest) StartKey(startKey string) ApiPartitionDesignDocViewRequest {
	r.startKey = &startKey
	return r
}

// Return records starting with the specified document ID. Ignored if startkey is not set.
func (r ApiPartitionDesignDocViewRequest) StartkeyDocid(startkeyDocid string) ApiPartitionDesignDocViewRequest {
	r.startkeyDocid = &startkeyDocid
	return r
}

// Alias for startkey_docid param
func (r ApiPartitionDesignDocViewRequest) StartKeyDocId(startKeyDocId string) ApiPartitionDesignDocViewRequest {
	r.startKeyDocId = &startKeyDocId
	return r
}

// Whether or not the view in question should be updated prior to responding to the user. Supported values: true, false, lazy. Default is true. 
func (r ApiPartitionDesignDocViewRequest) Update(update string) ApiPartitionDesignDocViewRequest {
	r.update = &update
	return r
}

// Whether to include in the response an update_seq value indicating the sequence id of the database the view reflects. Default is false.
func (r ApiPartitionDesignDocViewRequest) UpdateSeq(updateSeq bool) ApiPartitionDesignDocViewRequest {
	r.updateSeq = &updateSeq
	return r
}

func (r ApiPartitionDesignDocViewRequest) Execute() (*Pagination, *http.Response, error) {
	return r.ApiService.PartitionDesignDocViewExecute(r)
}

/*
PartitionDesignDocView Executes the specified view function from the specified design document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param partition Partition name
 @param ddoc Design document id
 @param view View function name
 @return ApiPartitionDesignDocViewRequest
*/
func (a *PartitionApiService) PartitionDesignDocView(ctx context.Context, db string, partition string, ddoc string, view string) ApiPartitionDesignDocViewRequest {
	return ApiPartitionDesignDocViewRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		partition: partition,
		ddoc: ddoc,
		view: view,
	}
}

// Execute executes the request
//  @return Pagination
func (a *PartitionApiService) PartitionDesignDocViewExecute(r ApiPartitionDesignDocViewRequest) (*Pagination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Pagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartitionApiService.PartitionDesignDocView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_partition/{partition}/_design/{ddoc}/_view/{view}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partition"+"}", url.PathEscape(parameterValueToString(r.partition, "partition")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ddoc"+"}", url.PathEscape(parameterValueToString(r.ddoc, "ddoc")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"view"+"}", url.PathEscape(parameterValueToString(r.view, "view")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.conflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicts", r.conflicts, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.endkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endkey", r.endkey, "")
	}
	if r.endKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_key", r.endKey, "")
	}
	if r.endkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endkey_docid", r.endkeyDocid, "")
	}
	if r.endKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_key_doc_id", r.endKeyDocId, "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.groupLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_level", r.groupLevel, "")
	}
	if r.includeDocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_docs", r.includeDocs, "")
	}
	if r.attachments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachments", r.attachments, "")
	}
	if r.attEncodingInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "att_encoding_info", r.attEncodingInfo, "")
	}
	if r.inclusiveEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclusive_end", r.inclusiveEnd, "")
	}
	if r.revsInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revs_info", r.revsInfo, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.keys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keys", r.keys, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.reduce != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reduce", r.reduce, "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "")
	}
	if r.sorted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sorted", r.sorted, "")
	}
	if r.stable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stable", r.stable, "")
	}
	if r.stale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stale", r.stale, "")
	}
	if r.startkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey", r.startkey, "")
	}
	if r.startKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key", r.startKey, "")
	}
	if r.startkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey_docid", r.startkeyDocid, "")
	}
	if r.startKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key_doc_id", r.startKeyDocId, "")
	}
	if r.update != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update", r.update, "")
	}
	if r.updateSeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_seq", r.updateSeq, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPartitionDesignDocViewPostRequest struct {
	ctx context.Context
	ApiService *PartitionApiService
	db string
	partition string
	ddoc string
	view string
	body *Keys
	conflicts *bool
	descending *bool
	endkey *string
	endKey *string
	endkeyDocid *string
	endKeyDocId *string
	group *bool
	groupLevel *int32
	includeDocs *bool
	attachments *bool
	attEncodingInfo *bool
	inclusiveEnd *bool
	revsInfo *bool
	key *string
	keys *string
	limit *int32
	reduce *bool
	skip *int32
	sorted *bool
	stable *bool
	stale *string
	startkey *string
	startKey *string
	startkeyDocid *string
	startKeyDocId *string
	update *string
	updateSeq *bool
}

func (r ApiPartitionDesignDocViewPostRequest) Body(body Keys) ApiPartitionDesignDocViewPostRequest {
	r.body = &body
	return r
}

// Include conflicts information in response. Ignored if include_docs isn’t true. Default is false.
func (r ApiPartitionDesignDocViewPostRequest) Conflicts(conflicts bool) ApiPartitionDesignDocViewPostRequest {
	r.conflicts = &conflicts
	return r
}

// Return the documents in descending order by key. Default is false.
func (r ApiPartitionDesignDocViewPostRequest) Descending(descending bool) ApiPartitionDesignDocViewPostRequest {
	r.descending = &descending
	return r
}

// Stop returning records when the specified key is reached.
func (r ApiPartitionDesignDocViewPostRequest) Endkey(endkey string) ApiPartitionDesignDocViewPostRequest {
	r.endkey = &endkey
	return r
}

// Alias for endkey param
func (r ApiPartitionDesignDocViewPostRequest) EndKey(endKey string) ApiPartitionDesignDocViewPostRequest {
	r.endKey = &endKey
	return r
}

// Stop returning records when the specified document ID is reached. Ignored if endkey is not set.
func (r ApiPartitionDesignDocViewPostRequest) EndkeyDocid(endkeyDocid string) ApiPartitionDesignDocViewPostRequest {
	r.endkeyDocid = &endkeyDocid
	return r
}

// Alias for endkey_docid.
func (r ApiPartitionDesignDocViewPostRequest) EndKeyDocId(endKeyDocId string) ApiPartitionDesignDocViewPostRequest {
	r.endKeyDocId = &endKeyDocId
	return r
}

// Group the results using the reduce function to a group or single row. Implies reduce is true and the maximum group_level. Default is false.
func (r ApiPartitionDesignDocViewPostRequest) Group(group bool) ApiPartitionDesignDocViewPostRequest {
	r.group = &group
	return r
}

// Specify the group level to be used. Implies group is true.
func (r ApiPartitionDesignDocViewPostRequest) GroupLevel(groupLevel int32) ApiPartitionDesignDocViewPostRequest {
	r.groupLevel = &groupLevel
	return r
}

// Include the associated document with each row. Default is false.
func (r ApiPartitionDesignDocViewPostRequest) IncludeDocs(includeDocs bool) ApiPartitionDesignDocViewPostRequest {
	r.includeDocs = &includeDocs
	return r
}

// Include the Base64-encoded content of attachments in the documents that are included if include_docs is true. Ignored if include_docs isn’t true. Default is false.
func (r ApiPartitionDesignDocViewPostRequest) Attachments(attachments bool) ApiPartitionDesignDocViewPostRequest {
	r.attachments = &attachments
	return r
}

// Include encoding information in attachment stubs if include_docs is true and the particular attachment is compressed. Ignored if include_docs isn’t true. Default is false.
func (r ApiPartitionDesignDocViewPostRequest) AttEncodingInfo(attEncodingInfo bool) ApiPartitionDesignDocViewPostRequest {
	r.attEncodingInfo = &attEncodingInfo
	return r
}

// Specifies whether the specified end key should be included in the result. Default is true.
func (r ApiPartitionDesignDocViewPostRequest) InclusiveEnd(inclusiveEnd bool) ApiPartitionDesignDocViewPostRequest {
	r.inclusiveEnd = &inclusiveEnd
	return r
}

// Includes detailed information for all known document revisions. Default is false
func (r ApiPartitionDesignDocViewPostRequest) RevsInfo(revsInfo bool) ApiPartitionDesignDocViewPostRequest {
	r.revsInfo = &revsInfo
	return r
}

// eturn only documents that match the specified key.
func (r ApiPartitionDesignDocViewPostRequest) Key(key string) ApiPartitionDesignDocViewPostRequest {
	r.key = &key
	return r
}

// Return only documents where the key matches one of the keys specified in the array.
func (r ApiPartitionDesignDocViewPostRequest) Keys(keys string) ApiPartitionDesignDocViewPostRequest {
	r.keys = &keys
	return r
}

// Limit the number of the returned documents to the specified number.
func (r ApiPartitionDesignDocViewPostRequest) Limit(limit int32) ApiPartitionDesignDocViewPostRequest {
	r.limit = &limit
	return r
}

// Use the reduction function. Default is true when a reduce function is defined.
func (r ApiPartitionDesignDocViewPostRequest) Reduce(reduce bool) ApiPartitionDesignDocViewPostRequest {
	r.reduce = &reduce
	return r
}

// Skip this number of records before starting to return the results. Default is 0.
func (r ApiPartitionDesignDocViewPostRequest) Skip(skip int32) ApiPartitionDesignDocViewPostRequest {
	r.skip = &skip
	return r
}

// Sort returned rows (see Sorting Returned Rows). Setting this to false offers a performance boost. The total_rows and offset fields are not available when this is set to false. Default is true.
func (r ApiPartitionDesignDocViewPostRequest) Sorted(sorted bool) ApiPartitionDesignDocViewPostRequest {
	r.sorted = &sorted
	return r
}

// Whether or not the view results should be returned from a stable set of shards. Default is false.
func (r ApiPartitionDesignDocViewPostRequest) Stable(stable bool) ApiPartitionDesignDocViewPostRequest {
	r.stable = &stable
	return r
}

// Allow the results from a stale view to be used. Supported values: ok and update_after. ok is equivalent to stable&#x3D;true&amp;update&#x3D;false. update_after is equivalent to stable&#x3D;true&amp;update&#x3D;lazy. The default behavior is equivalent to stable&#x3D;false&amp;update&#x3D;true. Note that this parameter is deprecated. Use stable and update instead. See Views Generation for more details. 
func (r ApiPartitionDesignDocViewPostRequest) Stale(stale string) ApiPartitionDesignDocViewPostRequest {
	r.stale = &stale
	return r
}

// Return records starting with the specified key.
func (r ApiPartitionDesignDocViewPostRequest) Startkey(startkey string) ApiPartitionDesignDocViewPostRequest {
	r.startkey = &startkey
	return r
}

// Alias for startkey.
func (r ApiPartitionDesignDocViewPostRequest) StartKey(startKey string) ApiPartitionDesignDocViewPostRequest {
	r.startKey = &startKey
	return r
}

// Return records starting with the specified document ID. Ignored if startkey is not set.
func (r ApiPartitionDesignDocViewPostRequest) StartkeyDocid(startkeyDocid string) ApiPartitionDesignDocViewPostRequest {
	r.startkeyDocid = &startkeyDocid
	return r
}

// Alias for startkey_docid param
func (r ApiPartitionDesignDocViewPostRequest) StartKeyDocId(startKeyDocId string) ApiPartitionDesignDocViewPostRequest {
	r.startKeyDocId = &startKeyDocId
	return r
}

// Whether or not the view in question should be updated prior to responding to the user. Supported values: true, false, lazy. Default is true. 
func (r ApiPartitionDesignDocViewPostRequest) Update(update string) ApiPartitionDesignDocViewPostRequest {
	r.update = &update
	return r
}

// Whether to include in the response an update_seq value indicating the sequence id of the database the view reflects. Default is false.
func (r ApiPartitionDesignDocViewPostRequest) UpdateSeq(updateSeq bool) ApiPartitionDesignDocViewPostRequest {
	r.updateSeq = &updateSeq
	return r
}

func (r ApiPartitionDesignDocViewPostRequest) Execute() (*Pagination, *http.Response, error) {
	return r.ApiService.PartitionDesignDocViewPostExecute(r)
}

/*
PartitionDesignDocViewPost Executes the specified view function from the specified design document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param partition Partition name
 @param ddoc Design document id
 @param view View function name
 @return ApiPartitionDesignDocViewPostRequest
*/
func (a *PartitionApiService) PartitionDesignDocViewPost(ctx context.Context, db string, partition string, ddoc string, view string) ApiPartitionDesignDocViewPostRequest {
	return ApiPartitionDesignDocViewPostRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		partition: partition,
		ddoc: ddoc,
		view: view,
	}
}

// Execute executes the request
//  @return Pagination
func (a *PartitionApiService) PartitionDesignDocViewPostExecute(r ApiPartitionDesignDocViewPostRequest) (*Pagination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Pagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartitionApiService.PartitionDesignDocViewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_partition/{partition}/_design/{ddoc}/_view/{view}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partition"+"}", url.PathEscape(parameterValueToString(r.partition, "partition")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ddoc"+"}", url.PathEscape(parameterValueToString(r.ddoc, "ddoc")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"view"+"}", url.PathEscape(parameterValueToString(r.view, "view")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.conflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicts", r.conflicts, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.endkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endkey", r.endkey, "")
	}
	if r.endKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_key", r.endKey, "")
	}
	if r.endkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endkey_docid", r.endkeyDocid, "")
	}
	if r.endKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_key_doc_id", r.endKeyDocId, "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.groupLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_level", r.groupLevel, "")
	}
	if r.includeDocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_docs", r.includeDocs, "")
	}
	if r.attachments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachments", r.attachments, "")
	}
	if r.attEncodingInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "att_encoding_info", r.attEncodingInfo, "")
	}
	if r.inclusiveEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclusive_end", r.inclusiveEnd, "")
	}
	if r.revsInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revs_info", r.revsInfo, "")
	}
	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.keys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keys", r.keys, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.reduce != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reduce", r.reduce, "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "")
	}
	if r.sorted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sorted", r.sorted, "")
	}
	if r.stable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stable", r.stable, "")
	}
	if r.stale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stale", r.stale, "")
	}
	if r.startkey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey", r.startkey, "")
	}
	if r.startKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key", r.startKey, "")
	}
	if r.startkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey_docid", r.startkeyDocid, "")
	}
	if r.startKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key_doc_id", r.startKeyDocId, "")
	}
	if r.update != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update", r.update, "")
	}
	if r.updateSeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_seq", r.updateSeq, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPartitionDocGetAllRequest struct {
	ctx context.Context
	ApiService *PartitionApiService
	db string
	partition string
	conflicts *bool
	descending *bool
	group *bool
	groupLevel *int32
	includeDocs *bool
	attachments *bool
	attEncodingInfo *bool
	inclusiveEnd *bool
	limit *int32
	reduce *bool
	skip *int32
	sorted *bool
	stable *bool
	stale *string
	startkeyDocid *string
	startKeyDocId *string
	update *string
	updateSeq *bool
}

// Include conflicts information in response. Ignored if include_docs isn’t true. Default is false.
func (r ApiPartitionDocGetAllRequest) Conflicts(conflicts bool) ApiPartitionDocGetAllRequest {
	r.conflicts = &conflicts
	return r
}

// Return the documents in descending order by key. Default is false.
func (r ApiPartitionDocGetAllRequest) Descending(descending bool) ApiPartitionDocGetAllRequest {
	r.descending = &descending
	return r
}

// Group the results using the reduce function to a group or single row. Implies reduce is true and the maximum group_level. Default is false.
func (r ApiPartitionDocGetAllRequest) Group(group bool) ApiPartitionDocGetAllRequest {
	r.group = &group
	return r
}

// Specify the group level to be used. Implies group is true.
func (r ApiPartitionDocGetAllRequest) GroupLevel(groupLevel int32) ApiPartitionDocGetAllRequest {
	r.groupLevel = &groupLevel
	return r
}

// Include the associated document with each row. Default is false.
func (r ApiPartitionDocGetAllRequest) IncludeDocs(includeDocs bool) ApiPartitionDocGetAllRequest {
	r.includeDocs = &includeDocs
	return r
}

// Include the Base64-encoded content of attachments in the documents that are included if include_docs is true. Ignored if include_docs isn’t true. Default is false.
func (r ApiPartitionDocGetAllRequest) Attachments(attachments bool) ApiPartitionDocGetAllRequest {
	r.attachments = &attachments
	return r
}

// Include encoding information in attachment stubs if include_docs is true and the particular attachment is compressed. Ignored if include_docs isn’t true. Default is false.
func (r ApiPartitionDocGetAllRequest) AttEncodingInfo(attEncodingInfo bool) ApiPartitionDocGetAllRequest {
	r.attEncodingInfo = &attEncodingInfo
	return r
}

// Specifies whether the specified end key should be included in the result. Default is true.
func (r ApiPartitionDocGetAllRequest) InclusiveEnd(inclusiveEnd bool) ApiPartitionDocGetAllRequest {
	r.inclusiveEnd = &inclusiveEnd
	return r
}

// Limit the number of the returned documents to the specified number.
func (r ApiPartitionDocGetAllRequest) Limit(limit int32) ApiPartitionDocGetAllRequest {
	r.limit = &limit
	return r
}

// Use the reduction function. Default is true when a reduce function is defined.
func (r ApiPartitionDocGetAllRequest) Reduce(reduce bool) ApiPartitionDocGetAllRequest {
	r.reduce = &reduce
	return r
}

// Skip this number of records before starting to return the results. Default is 0.
func (r ApiPartitionDocGetAllRequest) Skip(skip int32) ApiPartitionDocGetAllRequest {
	r.skip = &skip
	return r
}

// Sort returned rows (see Sorting Returned Rows). Setting this to false offers a performance boost. The total_rows and offset fields are not available when this is set to false. Default is true.
func (r ApiPartitionDocGetAllRequest) Sorted(sorted bool) ApiPartitionDocGetAllRequest {
	r.sorted = &sorted
	return r
}

// Whether or not the view results should be returned from a stable set of shards. Default is false.
func (r ApiPartitionDocGetAllRequest) Stable(stable bool) ApiPartitionDocGetAllRequest {
	r.stable = &stable
	return r
}

// Allow the results from a stale view to be used. Supported values: ok and update_after. ok is equivalent to stable&#x3D;true&amp;update&#x3D;false. update_after is equivalent to stable&#x3D;true&amp;update&#x3D;lazy. The default behavior is equivalent to stable&#x3D;false&amp;update&#x3D;true. Note that this parameter is deprecated. Use stable and update instead. See Views Generation for more details. 
func (r ApiPartitionDocGetAllRequest) Stale(stale string) ApiPartitionDocGetAllRequest {
	r.stale = &stale
	return r
}

// Return records starting with the specified document ID. Ignored if startkey is not set.
func (r ApiPartitionDocGetAllRequest) StartkeyDocid(startkeyDocid string) ApiPartitionDocGetAllRequest {
	r.startkeyDocid = &startkeyDocid
	return r
}

// Alias for startkey_docid param
func (r ApiPartitionDocGetAllRequest) StartKeyDocId(startKeyDocId string) ApiPartitionDocGetAllRequest {
	r.startKeyDocId = &startKeyDocId
	return r
}

// Whether or not the view in question should be updated prior to responding to the user. Supported values: true, false, lazy. Default is true. 
func (r ApiPartitionDocGetAllRequest) Update(update string) ApiPartitionDocGetAllRequest {
	r.update = &update
	return r
}

// Whether to include in the response an update_seq value indicating the sequence id of the database the view reflects. Default is false.
func (r ApiPartitionDocGetAllRequest) UpdateSeq(updateSeq bool) ApiPartitionDocGetAllRequest {
	r.updateSeq = &updateSeq
	return r
}

func (r ApiPartitionDocGetAllRequest) Execute() (*Pagination, *http.Response, error) {
	return r.ApiService.PartitionDocGetAllExecute(r)
}

/*
PartitionDocGetAll Executes the built-in _all_docs view

This endpoint is a convenience endpoint for automatically setting bounds on the provided partition range. Similar results can be had by using the global /db/_all_docs endpoint with appropriately configured values for start_key and end_key.

Refer to the view endpoint documentation for a complete description of the available query parameters and the format of the returned data.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param partition Partition name
 @return ApiPartitionDocGetAllRequest
*/
func (a *PartitionApiService) PartitionDocGetAll(ctx context.Context, db string, partition string) ApiPartitionDocGetAllRequest {
	return ApiPartitionDocGetAllRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		partition: partition,
	}
}

// Execute executes the request
//  @return Pagination
func (a *PartitionApiService) PartitionDocGetAllExecute(r ApiPartitionDocGetAllRequest) (*Pagination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Pagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartitionApiService.PartitionDocGetAll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_partition/{partition}/_all_docs"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partition"+"}", url.PathEscape(parameterValueToString(r.partition, "partition")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.conflicts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "conflicts", r.conflicts, "")
	}
	if r.descending != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descending", r.descending, "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.groupLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_level", r.groupLevel, "")
	}
	if r.includeDocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_docs", r.includeDocs, "")
	}
	if r.attachments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachments", r.attachments, "")
	}
	if r.attEncodingInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "att_encoding_info", r.attEncodingInfo, "")
	}
	if r.inclusiveEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inclusive_end", r.inclusiveEnd, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.reduce != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reduce", r.reduce, "")
	}
	if r.skip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip", r.skip, "")
	}
	if r.sorted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sorted", r.sorted, "")
	}
	if r.stable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stable", r.stable, "")
	}
	if r.stale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stale", r.stale, "")
	}
	if r.startkeyDocid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startkey_docid", r.startkeyDocid, "")
	}
	if r.startKeyDocId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_key_doc_id", r.startKeyDocId, "")
	}
	if r.update != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update", r.update, "")
	}
	if r.updateSeq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_seq", r.updateSeq, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPartitionInfoRequest struct {
	ctx context.Context
	ApiService *PartitionApiService
	db string
	partition string
}

func (r ApiPartitionInfoRequest) Execute() (*Partition, *http.Response, error) {
	return r.ApiService.PartitionInfoExecute(r)
}

/*
PartitionInfo This endpoint returns information describing the provided partition. It includes document and deleted document counts along with external and active data sizes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param db Database name
 @param partition Partition name
 @return ApiPartitionInfoRequest
*/
func (a *PartitionApiService) PartitionInfo(ctx context.Context, db string, partition string) ApiPartitionInfoRequest {
	return ApiPartitionInfoRequest{
		ApiService: a,
		ctx: ctx,
		db: db,
		partition: partition,
	}
}

// Execute executes the request
//  @return Partition
func (a *PartitionApiService) PartitionInfoExecute(r ApiPartitionInfoRequest) (*Partition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Partition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartitionApiService.PartitionInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{db}/_partition/{partition}"
	localVarPath = strings.Replace(localVarPath, "{"+"db"+"}", url.PathEscape(parameterValueToString(r.db, "db")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"partition"+"}", url.PathEscape(parameterValueToString(r.partition, "partition")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
